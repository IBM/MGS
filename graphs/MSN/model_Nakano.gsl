#include "Topology.h"
/// PLAN
// Add astrocyte as a new neuron with Kir4.1
//    which regulate synapse [K+]_o and branch [K+]_o
//    or emulate the effect of increasing [K+]_o

#include "../../nti/include/MaxComputeOrder.h"
#define _CCAT(x,y) x ## y 
#define CCAT(x,y) _CCAT(x,y)
#define _STR(x) #x 
#define STR(x) _STR(x)

#define CA_DCA 4.4        // 0.4 um^2/ms unbuffered
#define CA_BETA 0.002     // 0.05 dimensionless, Wagner and Keizer buffering constant
#define CA_CLEARANCE 1.1  // 1.1, 0.5 ms^-1
#define CA_BASELINE 0.1   // uM
#define Camyo_DiffusionConstant 4.4   // [um^2/ms]  unbuffered
#define Camyo_EffectiveDiffusionConstant  ??? // [um^2/ms] unbuffered+buffered

//#define Camyo_beta   0.002     // dimensionless 
#define Camyo_beta 0.05 // [Wagner and Keizer buffering constant]

#define CaER_DiffusionConstant 
#define CaER_EffectiveDiffusionConstant
#define Camyo_clearancerate 
// Baseline values [NOTE: The unit differences]
#define Camyo_value  0.1   // [uM]
#define CaER_value   500   // [uM]
#define Na_i_value   12.0  // [mM]
#define Na_o_value   145.0 // [mM]
#define K_i_value    139.0 // [mM]
#define K_o_value     4.0  // [mM]
#define Ra_value 0.001     // [mM]
#define E_leak_value -90.0 // [mM]

//CONNECTOR FUNCTOR
/*{{{*/
Connector PolyConnectorFunctor();   
PolyConnectorFunctor polyConnect();
/*}}}*/

//PHASES DEFINITION
/*{{{*/
// order of initialization
//  1. initial states for solvers, Voltage, Concentrations
//  2. initial coefficients for solvers, derived parameters, Junctions' data, reversal potentials
//  3. initial values of gating variables
//  4. initial values of VariableTypes
//  5. (not being used)  
//  6. (not being used)
InitPhases = { initialize1, initialize2, initialize3, initialize4, initialize5, initialize6 };

RuntimePhases = {
/*{{{*/
updateNMDADepPlasticity, solveChannels, predictJunction,
#if MAX_COMPUTE_ORDER>6
      forwardSolve7,
#endif
#if MAX_COMPUTE_ORDER>5  
      forwardSolve6,
#endif
#if MAX_COMPUTE_ORDER>4
      forwardSolve5,  
#endif
#if MAX_COMPUTE_ORDER>3
      forwardSolve4,
#endif
#if MAX_COMPUTE_ORDER>2
      forwardSolve3,
#endif
#if MAX_COMPUTE_ORDER>1
      forwardSolve2,
#endif
#if MAX_COMPUTE_ORDER>0 
      forwardSolve1,
#endif
      solve, 
#if MAX_COMPUTE_ORDER>0 
      backwardSolve1,
#endif
#if MAX_COMPUTE_ORDER>1
      backwardSolve2,
#endif  
#if MAX_COMPUTE_ORDER>2
      backwardSolve3,
#endif
#if MAX_COMPUTE_ORDER>3 
      backwardSolve4,
#endif
#if MAX_COMPUTE_ORDER>4
      backwardSolve5,
#endif
#if MAX_COMPUTE_ORDER>5
      backwardSolve6,
#endif
#if MAX_COMPUTE_ORDER>6
      backwardSolve7,
#endif
      correctJunction, finish
/*}}}*/
 };

FinalPhases = { finalize };
/*}}}*/

//GRANULE MAPPER DEFINITION
// a. declaration
// b. instantiation
GranuleMapper GridGranuleMapper(string description, list<int> dimensions, list<int> densityVector);
GridGranuleMapper tissueGM("Tissue Grid's GridGranuleMapper", { _X_ , _Y_ , _Z_ }, {1});

//TISSUE FUNCTOR
/*{{{*/
//FUNCTORS DEFINITION
Layout TissueLayoutFunctor();
TissueLayoutFunctor tissueLayoutFunctor();    

NodeInitializer TissueNodeInitFunctor();
TissueNodeInitFunctor tissueNodeInitFunctor();

Connector TissueConnectorFunctor();
TissueConnectorFunctor tissueConnectorFunctor();

Functor TissueProbeFunctor();
TissueProbeFunctor tissueProbeFunctor();
//TISSUEFUNCTOR DEFINITION
Functor TissueFunctor(string commandLine, string commandLineModification, 
		string channelParamaterFile, string synapseParameteurFile,
		Functor, Functor, Functor, Functor, int compartmentSize);
String strArg1("neurons.txt -p params/DevParams.par")
String strArg1_supplement("-p params/DetParams.par -n cost-volume")
String strArg2("params/CptParams.par")
String strArg3("params/ChanParams.par")
String strArg4("params/SynParams.par")
TissueFunctor  tissueFunctor(strArg1,
		strArg1_supplement,
		strArg2,
		strArg3,
		strArg4,
		tissueLayoutFunctor, tissueNodeInitFunctor, tissueConnectorFunctor,
		tissueProbeFunctor
		);
/*}}}*/

//NODETYPE DEFINITION
/*{{{*/
// 1. BRANCH NODE + JUNCTION NODE
/*{{{*/
//   1.0. - Compute Nodes
/*{{{*/
#if MAX_COMPUTE_ORDER>0
NodeType BackwardSolvePoint0 { produceInitialState->initialize1,
        produceBackwardSolution->solve };
NodeType ForwardSolvePoint1 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve1 };
#endif

#if MAX_COMPUTE_ORDER>1
NodeType BackwardSolvePoint1 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve1 };
NodeType ForwardSolvePoint2 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve2 };
#endif

#if MAX_COMPUTE_ORDER>2
NodeType BackwardSolvePoint2 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve2 };
NodeType ForwardSolvePoint3 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve3 };
#endif
  
#if MAX_COMPUTE_ORDER>3

NodeType BackwardSolvePoint3 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve3 };
NodeType ForwardSolvePoint4 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve4 };
#endif

#if MAX_COMPUTE_ORDER>4
NodeType BackwardSolvePoint4 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve4 };
NodeType ForwardSolvePoint5 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve5 };
#endif

#if MAX_COMPUTE_ORDER>5
NodeType BackwardSolvePoint5 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve5 };
NodeType ForwardSolvePoint6 { produceInitialState->initialize1,
          produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve6 };
#endif

#if MAX_COMPUTE_ORDER>6
NodeType BackwardSolvePoint6 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve6 };
NodeType ForwardSolvePoint7 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve7 };
#endif

/*}}}*/
//   1.1. - Voltage
/*{{{*/
NodeType HodgkinHuxleyVoltage( <
      Ra= Ra_value,      // Gohm*um
      Na= Na_i_value,          // mM
      K= K_i,            // mM 
      E_leak=i E_leak_value        // mV
           >) { initializeCompartmentData->initialize2 };
NodeType HodgkinHuxleyVoltageJunction (<
      Ra= Ra_value,       // Gohm*um
      Na= Na_i_value,        // mM
      K= K_i_value,        // mM 
      E_leak= E_leak_value    // mV
        >) { initializeJunction->initialize2 };//NOTE: there is no need for name-mapping for 
                             //junctionPoint() RuntimePhase's kernels 
                            //(only mapping if the name is different from what defined in GSL's xxxPhases) 

NodeType VoltageEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedVoltage-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedVoltage->solve,
#endif
        produceFinishedVoltage->finish
      };
NodeType VoltageJunctionPoint { 
        produceInitialState->initialize1, produceVoltage->predictJunction 
      };
/*}}}*/
//   1.2. - [Ca]intracellular
/*{{{*/
NodeType CaConcentration (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA, // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
           >) { initializeCompartmentData->initialize2, deriveParameters->initialize2 };

NodeType CaConcentrationEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedCaConcentration-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedCaConcentration->solve,
#endif
        produceFinishedCaConcentration->finish
      };
NodeType CaConcentrationJunction (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA,  // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
        >) { deriveParameters->initialize2, initializeJunction->initialize2 };
NodeType CaConcentrationJunctionPoint { 
         produceInitialState->initialize1, produceCaConcentration->predictJunction };
/*}}}*/
//   1.3. - [Ca]ER
/*{{{*/
NodeType CaERConcentration (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA, // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
           >) { initializeCaConcentration->initialize2, deriveParameters->initialize2 };

//QUESTION: Can we reuse ???
//NodeType CaConcentrationEndPoint { produceInitialState->initialize1,
//#if MAX_COMPUTE_ORDER>0
//        produceSolvedCaConcentration-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
//#else
//        produceSolvedCaConcentration->solve,
//#endif
//        produceFinishedCaConcentration->finish
//      };
NodeType CaERConcentrationJunction (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA,  // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
        >) { deriveParameters->initialize2, initializeJunction->initialize2 };
//QUESTION: Can we reuse ???
//NodeType CaConcentrationJunctionPoint { 
//         produceInitialState->initialize1, produceCaConcentration->predictJunction };

/*}}}*/
//   1.4. - [Dopamine]extracellular
/*{{{*/
NodeType DopamineConcentration (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA, // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
           >) { initializeCaConcentration->initialize2, deriveParameters->initialize2 };

NodeType DopamineConcentrationEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedCaConcentration-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedCaConcentration->solve,
#endif
        produceFinishedCaConcentration->finish
      };
NodeType DopamineConcentrationJunction (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA,  // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
        >) { deriveParameters->initialize2, initializeJunction->initialize2 };
NodeType DopamineConcentrationJunctionPoint { 
         produceInitialState->initialize1, produceCaConcentration->predictJunction };

/*}}}*/
/*}}}*/

// 2. RECEPTOR/CHANNEL NODE
/*{{{*/
//Na+ currents
/*{{{*/
   /* Fast-inactivating (transient) Na+ */
NodeType ChannelNat {computeE->initialize2, initialize->initialize3, update->solveChannels};
   /* Persistent Na+ current */
NodeType ChannelNap {computeE->initialize2, initialize->initialize3, update->solveChannels};
/*}}}*/
//K+ currents
/*{{{*/
  /* KAf - fast-inactivating 'A'-type K+ Kv4.2 data */
NodeType ChannelKAf { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* KAs - slow-inactivating 'A'-type K+ Kv1.2 data */
NodeType ChannelKAs { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* KRP 4-AP resistent persistent K+ current */
NodeType ChannelKRP { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* KDR - delayed-rectifier outward K+ Kv1.3 */
NodeType ChannelKDR { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* large-conductance BK Ca2+-dependent K+ current */
NodeType ChannelBK { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* small-conductance SK Ca2+-dependent K+ current */
  /* SK only present on secondary and tertary dendrites only */
NodeType ChannelSK { computeE->initialize2, initialize->initialize3, update->solveChannels };
/*}}}*/
//Ca2+ currents
/*{{{*/
  /* N-type Ca2+ Cav2.2 (high-voltaged activated) */
NodeType ChannelCaN { initialize->initialize3, update->solveChannels };
  /* P/Q-type Ca2+ Cav2.1 (high-voltaged activated) */
NodeType ChannelCaPQ { initialize->initialize3, update->solveChannels };
  /* R-type Ca2+ Cav2.3 (high-voltaged activated) */
NodeType ChannelCaR { initialize->initialize3, update->solveChannels };
  /* NOTE: L-type Cav1.1, Cav1.2, Cav1.3, Cav1.4 */
  /* L-type Ca2+ Cav1.2 and Cav1.3 (high-voltage activated)*/
//NodeType ChannelCaL { initialize->initialize3, update->solveChannels };
NodeType ChannelCaLv12 { initialize->initialize3, update->solveChannels };
NodeType ChannelCaLv13 { initialize->initialize3, update->solveChannels };
  /* T-type Ca2+ (low-voltage activated)*/
NodeType ChannelCaT { initialize->initialize3, update->solveChannels };
/*}}}*/
/*}}}*/

// 3. SYNAPSE
/*{{{*/
// 3.1. CHEMICAL SYNAPSE RECEPTOR
/*{{{*/
NodeType AMPAReceptor (<
          E=0.0,        // mV
          alpha=0.05, // uM^-1 msec^-1
          beta=2.0,    // msec^1
          Tmax=180,     // 160-190 uM
          Vp=2.0,       // mV
          Kp=5.0        // mV
          >) { initializeAMPA->initialize3, updateAMPA->solveChannels };
NodeType NMDAReceptor (<
          E = 0.0,       // mV
          alpha=0.000512,  // uM^-1 msec^-1
          beta=0.053,     // msec^1
          Tmax=180,      // 160-190 uM
          Vp=2.0,        // mV
                            Kp=5.0,        // mV
          plasticityOn = 0,
                            plasticityStartAt = 0, //ms
                            plasticityStopAt = 100000, //ms
          theta_d = 1.0,
          theta_p = 1.3,
          gamma_d = 100, // 331.9,
          gamma_p = 125, // 725.085,
          tau = 34600.3615, //ms
                w_th = 0.5,
          deltaNMDAR = 0, // Turns on/off changes in NMDARs
          alphaBuffer = 0.0175,
          tauBuffer = 3000
 >) { initializeNMDA->initialize3, updateNMDA->solveChannels };
NodeType GABAAReceptor (<
          E=-80.0,      // mV
          alpha=0.005,  // uM^-1 msec^-1
          beta=0.18,    // msec^1
          Tmax=185,     // 185 um
          Vp=2.0,       // mV
          Kp=5.0        // mV
          >) { initializeGABAA->initialize3, updateGABAA->solveChannels };
/*}}}*/
// 3.2. PRE-SYNAPSE NODE
/*{{{*/
NodeType PreSynapticPoint { produceInitialState->initialize2, produceState->finish };
/*}}}*/

// 3.3 CONNECXON - connecting a spine (2-compartment neuron) - with a branch
/*{{{*/
//NodeType Connexon { produceInitialVoltage->initialize2, produceVoltage->finish, computeState->solveChannels };
//NodeType Connexon_VmCai { produceInitialState->initialize2, produceState->finish, computeState->solveChannels };
NodeType Connexon_VmCaiER { produceInitialState->initialize2, produceState->finish, computeState->solveChannels };
/*}}}*/
/*}}}*/

// 4. CONSTANT
/*{{{*/
ConstantType ExtracellularMedium;
// Wolf et al. 
// [Ca]o = 5 mM, [Ca]i 0.001 mM
// 
ExtracellularMedium extracellularMedium<  Na=500.0,  // uM or mM???
                                          K=17.0,    // uM or mM???
                                          T=281,     // degK
                                          Ca=750.0,  // uM
                                          Mg=1.0>;   // uM
ConstantType TimeStep;
TimeStep timeStep< deltaT=0.010 >; // msec
/*}}}*/
// 5. TRIGGER
/*{{{*/
Trigger UnsignedTrigger(string description, Service svc, string operator, int criterion, int delay, string phaseName);
Trigger CompositeTrigger(string description, Trigger triggerA, int critA, string operator, Trigger triggerB, int critB, int delay, string phaseName);

UnsignedTrigger recOn("Iteration Trigger : !% 20", 
          ::Iteration, "!%", 20, 0, solveChannels ); //Record every ms
/*}}}*/

// 6. VARIABLES (stimulus, I/O)
/*{{{*/
//stimulus
//{{{
VariableType CurrentPulseGenerator { initialize->initialize1, update->solveChannels };
CurrentPulseGenerator synapseStimInj0<pattern="periodic", peak=0.1, duration=1, delay=200, period=600, last=3600, inc=0>;
CurrentPulseGenerator currentStimInj0<pattern="periodic", peak=2000, duration=3, period=620, delay=1785, last=3600, inc=0>; 
polyConnect(timeStep, currentStimInj0, <>, <>);
CurrentPulseGenerator currentStimInj1<pattern="periodic", peak=2000, duration=3, period=5000, delay=400, last=3600, inc=0>; 
polyConnect(timeStep, currentStimInj1, <>, <>);
//}}}

//I/O purpose
//{{{
VariableType VoltageDisplay{ initialize->initialize1 };
VoltageDisplay voltageDisplay<fileName="out/somaV.dat">;
voltageDisplay.dataCollection(<>) on recOn;

VariableType CalciumDisplay{ initialize->initialize4 };
CalciumDisplay calciumSomaDisplay<fileName="out/somaCa.dat">;
calciumSomaDisplay.dataCollection(<>) on recOn;

VoltageDisplay synapseVoltageDisplay0<fileName="out/synapseV0.dat">;
synapseVoltageDisplay0.dataCollection(<>) on recOn;
CalciumDisplay synapseCalciumDisplay0<fileName="out/synapseC0.dat">;
synapseCalciumDisplay0.dataCollection(<>) on recOn;
//}}}
/*}}}*/
/*}}}*/


Struct TissueSite;
//GRID DEFINITION
//MSN D1-like neuron
Grid MSN_D1Neuron{
/*{{{*/

	// GRID DIMENSION
	//_X_*_Y_*_Z_ = # processes in MPI
	// i.e. each volume is handled by one process
	Dimension( _X_, _Y_, _Z_ );

	// GRID LAYER
	//LAYER(name_of_layer, NodesAssociatedWithTheGivenLayer |
	//                     ConstantAssociatedWithTheGivenlayer |
	//                     VariableAssociatedWithTheGivenlayer,
	//     tissueFunctor("Layout", <nodekind="AValueIn") 
	//     )
	/*{{{*/
	  // LAYER BRANCHES (data as an array)
    /*{{{*/
      //NODETYPE
      //  1.0. - Compute Nodes
      /*{{{*/
#if MAX_COMPUTE_ORDER>0
	Layer(fwdSolvePoints1, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][1]">), <nodekind="ForwardSolvePoints[Voltage][1]">, tissueGM);
	Layer(bwdSolvePoints0, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][0]">), <nodekind="BackwardSolvePoints[Voltage][0]">, tissueGM);
	Layer(fwdSolvePoints1_Ca, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][1]">), <nodekind="ForwardSolvePoints[Calcium][1]">, tissueGM);
	Layer(bwdSolvePoints0_Ca, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][0]">), <nodekind="BackwardSolvePoints[Calcium][0]">, tissueGM);
	Layer(fwdSolvePoints1_CaER, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][1]">), <nodekind="ForwardSolvePoints[CalciumER][1]">, tissueGM);
	Layer(bwdSolvePoints0_CaER, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][0]">), <nodekind="BackwardSolvePoints[CalciumER][0]">, tissueGM);
#endif
#if MAX_COMPUTE_ORDER>1
	Layer(fwdSolvePoints2, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][2]">), <nodekind="ForwardSolvePoints[Voltage][2]">, tissueGM);
	Layer(bwdSolvePoints1, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][1]">), <nodekind="BackwardSolvePoints[Voltage][1]">, tissueGM);
	Layer(fwdSolvePoints2_Ca, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][2]">), <nodekind="ForwardSolvePoints[Calcium][2]">, tissueGM);
	Layer(bwdSolvePoints1_Ca, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][1]">), <nodekind="BackwardSolvePoints[Calcium][1]">, tissueGM);
	Layer(fwdSolvePoints2_CaER, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][2]">), <nodekind="ForwardSolvePoints[CalciumER][2]">, tissueGM);
	Layer(bwdSolvePoints1_CaER, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][1]">), <nodekind="BackwardSolvePoints[CalciumER][1]">, tissueGM);
#endif
#if MAX_COMPUTE_ORDER>2
	Layer(fwdSolvePoints3, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][3]">), <nodekind="ForwardSolvePoints[Voltage][3]">, tissueGM);
	Layer(bwdSolvePoints2, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][2]">), <nodekind="BackwardSolvePoints[Voltage][2]">, tissueGM);
	Layer(fwdSolvePoints3_Ca, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][3]">), <nodekind="ForwardSolvePoints[Calcium][3]">, tissueGM);
	Layer(bwdSolvePoints2_Ca, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][2]">), <nodekind="BackwardSolvePoints[Calcium][2]">, tissueGM);
	Layer(fwdSolvePoints3_CaER, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][3]">), <nodekind="ForwardSolvePoints[CalciumER][3]">, tissueGM);
	Layer(bwdSolvePoints2_CaER, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][2]">), <nodekind="BackwardSolvePoints[CalciumER][2]">, tissueGM);
#endif
#if MAX_COMPUTE_ORDER>3
	Layer(fwdSolvePoints4, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][4]">), <nodekind="ForwardSolvePoints[Voltage][4]">, tissueGM);
	Layer(bwdSolvePoints3, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][3]">), <nodekind="BackwardSolvePoints[Voltage][3]">, tissueGM);
	Layer(fwdSolvePoints4_Ca, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][4]">), <nodekind="ForwardSolvePoints[Calcium][4]">, tissueGM);
	Layer(bwdSolvePoints3_Ca, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][3]">), <nodekind="BackwardSolvePoints[Calcium][3]">, tissueGM);
	Layer(fwdSolvePoints4_CaER, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][4]">), <nodekind="ForwardSolvePoints[CalciumER][4]">, tissueGM);
	Layer(bwdSolvePoints3_CaER, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][3]">), <nodekind="BackwardSolvePoints[CalciumER][3]">, tissueGM);
#endif
#if MAX_COMPUTE_ORDER>4
	Layer(fwdSolvePoints5, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][5]">), <nodekind="ForwardSolvePoints[Voltage][5]">, tissueGM);
	Layer(bwdSolvePoints4, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][4]">), <nodekind="BackwardSolvePoints[Voltage][4]">, tissueGM);
	Layer(fwdSolvePoints5_Ca, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][5]">), <nodekind="ForwardSolvePoints[Calcium][5]">, tissueGM);
	Layer(bwdSolvePoints4_Ca, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][4]">), <nodekind="BackwardSolvePoints[Calcium][4]">, tissueGM);
	Layer(fwdSolvePoints5_CaER, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][5]">), <nodekind="ForwardSolvePoints[CalciumER][5]">, tissueGM);
	Layer(bwdSolvePoints4_CaER, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][4]">), <nodekind="BackwardSolvePoints[CalciumER][4]">, tissueGM);
#endif
#if MAX_COMPUTE_ORDER>5
	Layer(fwdSolvePoints6, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][6]">), <nodekind="ForwardSolvePoints[Voltage][6]">, tissueGM);
	Layer(bwdSolvePoints5, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][5]">), <nodekind="BackwardSolvePoints[Voltage][5]">, tissueGM);
	Layer(fwdSolvePoints6_Ca, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][6]">), <nodekind="ForwardSolvePoints[Calcium][6]">, tissueGM);
	Layer(bwdSolvePoints5_Ca, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][5]">), <nodekind="BackwardSolvePoints[Calcium][5]">, tissueGM);
	Layer(fwdSolvePoints6_CaER, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][6]">), <nodekind="ForwardSolvePoints[CalciumER][6]">, tissueGM);
	Layer(bwdSolvePoints5_CaER, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][5]">), <nodekind="BackwardSolvePoints[CalciumER][5]">, tissueGM);
#endif
#if MAX_COMPUTE_ORDER>6
	Layer(fwdSolvePoints7, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][7]">), <nodekind="ForwardSolvePoints[Voltage][7]">, tissueGM);
	Layer(bwdSolvePoints6, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][6]">), <nodekind="BackwardSolvePoints[Voltage][6]">, tissueGM);
	Layer(fwdSolvePoints7_Ca, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][7]">), <nodekind="ForwardSolvePoints[Calcium][7]">, tissueGM);
	Layer(bwdSolvePoints6_Ca, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][6]">), <nodekind="BackwardSolvePoints[Calcium][6]">, tissueGM);
	Layer(fwdSolvePoints7_CaER, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][7]">), <nodekind="ForwardSolvePoints[CalciumER][7]">, tissueGM);
	Layer(bwdSolvePoints6_CaER, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][6]">), <nodekind="BackwardSolvePoints[CalciumER][6]">, tissueGM);
#endif
      /*}}}*/
      
      //  1.1. - Voltage
	// NOTE: branches = a collection of branches, each branch is a multiple compartments variables
    //       endPoints = a collection of endPoint, each endPoint is treated as a single-compartment branch with data reference to the end-compartment of a branch
    //       junctions = a collection of junction, each is a single-compartment 
    //       junctionPoints = a collection of junctionPoint, each is a single-compartment reference to end-compartment of a junction
      /*{{{*/
	Layer(branches, HodgkinHuxleyVoltage, tissueFunctor("Layout", <nodekind="CompartmentVariables[Voltage]">), <nodekind="CompartmentVariables[Voltage]">, tissueGM);
	Layer(endPoints, VoltageEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[Voltage]">), <nodekind="EndPoints[Voltage]">, tissueGM);
    Layer(junctions, HodgkinHuxleyVoltageJunction, tissueFunctor("Layout", <nodekind="Junctions[Voltage]">), <nodekind="Junctions[Voltage]">, tissueGM);
    Layer(junctionPoints, VoltageJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[Voltage]">), <nodekind="JunctionPoints[Voltage]">, tissueGM);
      /*}}}*/
      //  1.2. - [Ca]intracellular
      /*{{{*/
	Layer(branches_Ca, CaConcentration, tissueFunctor("Layout", <nodekind="CompartmentVariables[Calcium]">), <nodekind="CompartmentVariables[Calcium]">, tissueGM);
	Layer(endPoints_Ca, CaConcentrationEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[Calcium]">), <nodekind="EndPoints[Calcium]">, tissueGM);
    Layer(junctions_Ca, CaConcentrationJunction, tissueFunctor("Layout", <nodekind="Junctions[Calcium]">), <nodekind="Junctions[Calcium]">, tissueGM);
	Layer(junctionPoints_Ca, CaConcentrationJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[Calcium]">), <nodekind="JunctionPoints[Calcium]">, tissueGM);
      /*}}}*/
      //  1.3. - [Ca]ER
      /*{{{*/
	Layer(branches_CaER, CaConcentration, tissueFunctor("Layout", <nodekind="CompartmentVariables[CalciumER]">), <nodekind="CompartmentVariables[CalciumER]">, tissueGM);
	Layer(endPoints_CaER, CaConcentrationEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[CalciumER]">), <nodekind="EndPoints[CalciumER]">, tissueGM);
    Layer(junctions_CaER, CaConcentrationJunction, tissueFunctor("Layout", <nodekind="Junctions[CalciumER]">), <nodekind="Junctions[CalciumER]">, tissueGM);
	Layer(junctionPoints_CaER, CaConcentrationJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[CalciumER]">), <nodekind="JunctionPoints[CalciumER]">, tissueGM);
      //  1.4. - [Dopamine]extracellular

    /*}}}*/
      // 2. RECEPTOR/CHANNEL    
	/*{{{*/
	Layer(NatChannels, ChannelNat, tissueFunctor("Layout", < nodekind="Channels[Nat]" >), < nodekind="Channels[Nat]" >, tissueGM);
	Layer(NapChannels, ChannelNap, tissueFunctor("Layout", < nodekind="Channels[Nap]" >), < nodekind="Channels[Nap]" >, tissueGM);
	Layer(KAfChannels, ChannelKAf, tissueFunctor("Layout", < nodekind="Channels[KAf]" >), < nodekind="Channels[KAf]" >, tissueGM);
	Layer(KAsChannels, ChannelKAs, tissueFunctor("Layout", < nodekind="Channels[KAs]" >), < nodekind="Channels[KAs]" >, tissueGM);
	Layer(KRPChannels, ChannelKRP, tissueFunctor("Layout", < nodekind="Channels[KRP]" >), < nodekind="Channels[KRP]" >, tissueGM);
	Layer( BKChannels, ChannelBK,  tissueFunctor("Layout", < nodekind="Channels[BK]" >), < nodekind="Channels[BK]" >, tissueGM);
	Layer( SKChannels, ChannelSK,  tissueFunctor("Layout", < nodekind="Channels[SK]" >), < nodekind="Channels[SK]" >, tissueGM);
	Layer(KDRChannels, ChannelKDR, tissueFunctor("Layout", < nodekind="Channels[KDR]" >), < nodekind="Channels[KDR]" >, tissueGM);
	Layer(CaNChannels, ChannelCaHVA, tissueFunctor("Layout", < nodekind="Channels[CaN]" >), < nodekind="Channels[CaN]" >, tissueGM);
	Layer(CaPQChannels, ChannelCaHVA, tissueFunctor("Layout", < nodekind="Channels[CaPQ]" >), < nodekind="Channels[CaPQ]" >, tissueGM);
	Layer(CaRChannels, ChannelCaHVA, tissueFunctor("Layout", < nodekind="Channels[CaR]" >), < nodekind="Channels[CaR]" >, tissueGM);
	Layer(CaLv12Channels, ChannelCaHVA, tissueFunctor("Layout", < nodekind="Channels[CaLv12]" >), < nodekind="Channels[CaLv12]" >, tissueGM);
	Layer(CaLv13Channels, ChannelCaHVA, tissueFunctor("Layout", < nodekind="Channels[CaLv13]" >), < nodekind="Channels[CaLv13]" >, tissueGM);
	Layer(CaTChannels, ChannelCaLVA, tissueFunctor("Layout", < nodekind="Channels[CaT]" >), < nodekind="Channels[CaT]" >, tissueGM);
	/*}}}*/
      // 3. SYNAPSES
      /*{{{*/
      // 3.1. CHEMICAL SYNAPSE RECEPTORS
      /*{{{*/
	Layer(AMPASynapses, AMPAReceptor, tissueFunctor("Layout", < nodekind="ChemicalSynapses[AMPA]" >), < nodekind="ChemicalSynapses[AMPA]" >, tissueGM);
	Layer(NMDASynapses, NMDAReceptor, tissueFunctor("Layout", < nodekind="ChemicalSynapses[NMDA]" >), < nodekind="ChemicalSynapses[NMDA]" >, tissueGM);
	Layer(GABAASynapses, GABAAReceptor, tissueFunctor("Layout", < nodekind="ChemicalSynapses[GABAA]" >), < nodekind="ChemicalSynapses[GABAA]" >, tissueGM);
      /*}}}*/
      // 3.2. PRE-SYNAPSE
	/*{{{*/
	Layer(PreSynapticPoints, PreSynapticPoint, tissueFunctor("Layout", < nodekind="PreSynapticPoints[Voltage]" >), < nodekind="PreSynapticPoints[Voltage]" >, tissueGM);
	/*}}}*/
      // 3.3. CONNECXON
      /*{{{*/
	Layer(DendriticSpines, Connexon, tissueFunctor("Layout", < nodekind="BidirectionalConnection[DenSpine]" >), < nodekind="BidirectionalConnection[DenSpine]" >, tissueGM);
      /*}}}*/
     /*}}}*/

	/*}}}*/

	// GRID - INIT NODES
	/*{{{*/
	// 1. BRANCHES NODES
	/*{{{*/
    // 1.0 - Compute  (all branches nodetypes)
	/*{{{*/
#if MAX_COMPUTE_ORDER>0
	InitNodes ( .[].Layer(fwdSolvePoints1), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints1_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints0), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints0_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if MAX_COMPUTE_ORDER>1
	InitNodes ( .[].Layer(fwdSolvePoints2), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints2_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints1), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints1_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if MAX_COMPUTE_ORDER>2
	InitNodes ( .[].Layer(fwdSolvePoints3), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints3_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints2), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints2_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if MAX_COMPUTE_ORDER>3
	InitNodes ( .[].Layer(fwdSolvePoints4), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints4_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints3), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints3_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if MAX_COMPUTE_ORDER>4
	InitNodes ( .[].Layer(fwdSolvePoints5), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints5_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints4), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints4_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if MAX_COMPUTE_ORDER>5
	InitNodes ( .[].Layer(fwdSolvePoints6), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints6_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints5), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints5_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if MAX_COMPUTE_ORDER>6
	InitNodes ( .[].Layer(fwdSolvePoints7), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(fwdSolvePoints7_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints6), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints6_Ca), tissueFunctor("NodeInit", <> ) );
#endif
    /*}}}*/
    // 1.1. - Voltage
    /*{{{*/
	InitNodes ( .[].Layer(branches), tissueFunctor("NodeInit", <
				compartmentalize = { "Vnew", 
				"Vcur", 
				"Aii", 
				"Aim", 
				"Aip", 
				"RHS", 
				},
				Vnew = {-85.00}//-64.1235}
				> ) );
	InitNodes ( .[].Layer(endPoints), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions), tissueFunctor("NodeInit", < Vnew = {-85.000} /*-64.3346}*/  > ) );
	InitNodes ( .[].Layer(junctionPoints), tissueFunctor("NodeInit", <> ) );
     /*}}}*/
    // 1.2. - [Ca]intrcellular
    /*{{{*/
	InitNodes ( .[].Layer(branches_Ca), tissueFunctor("NodeInit", <
				compartmentalize = {"Ca_new", 
				"Ca_cur", 
				"currentToConc",
				"Aii",
				"Aim", 
				"Aip", 
				"RHS"
				},
				Ca_new = {0.1}
				> ) );
	InitNodes ( .[].Layer(endPoints_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions_Ca), tissueFunctor("NodeInit", < Ca_new = {0.1} > ) ); 
	InitNodes ( .[].Layer(junctionPoints_Ca), tissueFunctor("NodeInit", <> ) );
    /*}}}*/
    // 1.3. - [Ca]ER
    /*{{{*/
	InitNodes ( .[].Layer(branches_CaER), tissueFunctor("NodeInit", <
				compartmentalize = {"CaER_new", 
				"CaER_cur", 
				"currentToConc",
				"Aii",
				"Aim", 
				"Aip", 
				"RHS"
				},
				CaER_new = {1.1} // [mM]
				> ) );
	InitNodes ( .[].Layer(endPoints_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions_CaER), tissueFunctor("NodeInit", < CaER_new = {1.2} > ) ); 
	InitNodes ( .[].Layer(junctionPoints_CaER), tissueFunctor("NodeInit", <> ) );
    /*}}}*/
    // 1.4. - [Dopamine]extracellular
    /*}}}*/

	// 2. RECEPTORS/CHANNELS NODES
	/*{{{*/
	InitNodes ( .[].Layer(NatChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0} 
				> ) ); 

	InitNodes ( .[].Layer(NapChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0} 
				> ) ); 

	InitNodes ( .[].Layer(KAfChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(KAsChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(KRPChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(BKChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(SKChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(KDRChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );

	InitNodes ( .[].Layer(CaNChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaNChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaPQChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaRChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaLv12Channels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaLv13Channels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaTChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );

	/*}}}*/
	// 3. SYNAPSES NODES 
    /*{{{*/ 
    // 3.1. SYNAPSE RECEPTORS
    /*{{{*/
	InitNodes ( .[].Layer(AMPASynapses), tissueFunctor("NodeInit", <
				gbar = 5.0 // 2.2223 nS/um^2
				> ) );

	InitNodes ( .[].Layer(NMDASynapses), tissueFunctor("NodeInit", <
				gbar = 5.0, w = 1.0 // 0.17 0.115 nS/um^2 // 
				> ) );

	InitNodes ( .[].Layer(GABAASynapses), tissueFunctor("NodeInit", <
				gbar = 0.50 // nS/um^2
				> ) );  
    /*}}}*/

    // 3.2. PRE-SYNAPSE
    /*{{{*/
	InitNodes ( .[].Layer(PreSynapticPoints), tissueFunctor("NodeInit", <> ) );
    /*}}}*/
    // 3.3. CONNECXON 
    /*{{{*/
    InitNodes ( .[].Layer(DendriticSpines), tissueFunctor("NodeInit", <
				I = 0.0,
				// I_Ca = 0, //TUAN: check this
				g = 2.0 // nS
				> ) );
    /*}}}*/
	/*}}}*/

	// GRID - CONNECT LAYERS with ...
    /*{{{*/
	// 1. with CONSTANTS
	/*{{{*/
	polyConnect(timeStep, .[].Layer(branches, junctions, branches_Ca, junctions_Ca), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(branches_CaER, junctions_CaER), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(NatChannels, NapChannels), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(KAfChannels, KAsChannels, KRPChannels, BKChannels, SKChannels, KDRChannels), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(CaNChannels, CaPQChannels, CaRChannels, CaLv12Channels, CaLv13Channels, CaTChannels), <>, <identifier="dt">);

	polyConnect(extracellularMedium, .[].Layer(NatChannels, NapChannels, HCNChannels, MKChannels, KpChannels, KtChannels, Kv31Channels, NMDASynapses, CahChannels, CalChannels, SKChannels), <>, <identifier="EC">);
	polyConnect(timeStep, .[].Layer(AMPASynapses), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(NMDASynapses), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(GABAASynapses), <>, <identifier="dt">);
	/*}}}*/

    //IMPORTANT: call this once you already have all Layers with NodeTypes required for the simulation
    tissueFunctor("Connect", <> );  // This is important to perform connections

    // 2. with VARIABLES (for I/O, stimulus)
	/*{{{*/
	polyConnect(timeStep, synapseStimInj0, <>, <>);
	polyConnect(synapseStimInj0, tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", BRANCHORDER=0, NEURON_INDEX=1>), <>, <identifier="stimulation">);

	TissueSite synapseSite0( -41.813584824468236, 175.47049244293586, -0.6457233469214552, 5.0 );

	polyConnect(timeStep, synapseVoltageDisplay0, <>, <>);
	polyConnect(tissueFunctor("Probe", <CATEGORY="BRANCH", TYPE="Voltage", NEURON_INDEX=0>), synapseVoltageDisplay0, <>, <site=synapseSite0>);

	polyConnect(timeStep, synapseCalciumDisplay0, <>, <>);
	polyConnect(tissueFunctor("Probe", <CATEGORY="BRANCH", TYPE="Calcium", NEURON_INDEX=0>), synapseCalciumDisplay0, <>, <site=synapseSite0>);


   TissueSite currentStimSite0( 0, 0, 0, 1.0 );
   polyConnect(currentStimInj0, tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", NEURON_INDEX=0>), <>, <identifier="stimulation", site=currentStimSite0>);

   TissueSite currentStimSite1( 0, 0, 0, 1.0 );
   polyConnect(currentStimInj1, tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", NEURON_INDEX=0>), <>, <identifier="stimulation", site=currentStimSite1>);

   polyConnect(timeStep, voltageDisplay, <>, <>);
   polyConnect( tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", BRANCHORDER=0>), voltageDisplay, <>, <>);

   polyConnect(timeStep, calciumSomaDisplay, <>, <>);
   polyConnect( tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Calcium", BRANCHORDER=0>), calciumSomaDisplay, <>, <>);

	/*}}}*/

    /*}}}*/

	/*{{{*/
	/*}}}*/
/*}}}*/
/*}}}*/
; //end grid

MSN_D1Neuron msn;

  //stop when correctJunction is called for a given number of iterations
UnsignedTrigger endTrig("Iteration Trigger to end or stop", 
		::Iteration, "==", 1000, 0, correctJunction); 

Stop on endTrig;

