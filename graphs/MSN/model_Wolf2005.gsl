#include "Topology.h"
/// PLAN
// Add astrocyte as a new neuron with Kir4.1
//    which regulate synapse [K+]_o and branch [K+]_o
//    or emulate the effect of increasing [K+]_o

#include "../../nti/include/MaxComputeOrder.h"
#define _CCAT(x,y) x ## y 
#define CCAT(x,y) _CCAT(x,y)
#define _STR(x) #x 
#define STR(x) _STR(x)

//SECTIONZ: Modify the data in this section for general setting
// Wolf et al. 
// [Ca]o = 5 mM, [Ca]i 0.001 mM
// 
//{{{
//{{{ Numerics
#define TimeStep_value   0.010 // [ms]
#define RecordInterval   20   // every ... timesteps
#define NumIterationsUntilEnd   1000   // unitless
//}}}
//{{{ Diffusion
#define CA_DCA 4.4        // 0.4 um^2/ms unbuffered
#define CA_BETA 0.002     // 0.05 dimensionless, Wagner and Keizer buffering constant
#define CA_CLEARANCE 1.1  // 1.1, 0.5 ms^-1
#define CA_BASELINE 0.1   // uM
#define Cacyto_DiffusionConstant 4.4   // [um^2/ms]  unbuffered
#define Cacyto_EffectiveDiffusionConstant  ??? // [um^2/ms] unbuffered+buffered

//#define Cacyto_beta   0.002     // dimensionless 
#define Cacyto_beta 0.05 // [Wagner and Keizer buffering constant]

#define CaER_DiffusionConstant 200.0   // units???
#define CaER_EffectiveDiffusionConstant  100.0  // units???
#define Cacyto_clearancerate     1.1  // units???
//}}}
//{{{ Concentration
// Baseline values [NOTE: The unit differences]
#define Cacyto_value  0.1e-3  // [mM]
#define CaER_value   1    // [mM]
#define Ca_o_value  1.8   // [mM]
#define Mg_o_value  1.5    // [mM]
#define Mg_i_value  0.8    // [mM]
#define Na_i_value   12.0  // [mM]
#define Na_o_value   145.0 // [mM]
#define K_i_value    139.0 // [mM]
#define K_o_value     4.0  // [mM]
#define Dopa_value   0.0   // [???]
//{{{ Condition
#define Ra_value 0.001     // [GOhm*um]
#define E_leak_value -90.0 // [mV]
  // NOTE: 310K = 37-degree Celcius (body)
  //       298K = 25-degree Celcius (room)
  //       295K = 22-degree Celcius (room)
  //              20.0-22.0-degree Celcius (room)
  //       281K = 7.85-degree Celcius (cold)
#define Temperature_value  281.0 // [K] Kelvin
#define Vrest_value  -85.0 // [mV]
//}}}
//}}}
//}}}

//CONNECTOR FUNCTOR
/*{{{*/
Connector PolyConnectorFunctor();   
PolyConnectorFunctor polyConnect();
/*}}}*/

//PHASES DEFINITION
/*{{{*/
// order of initialization
//  1. initial states for solvers, Voltage, Concentrations
//  2. initial coefficients for solvers, derived parameters, Junctions' data, reversal potentials
//  3. initial values of gating variables
//  4. initial values of VariableTypes
//  5. (not being used)  
//  6. (not being used)
InitPhases = { initialize1, initialize2, initialize3, initialize4, initialize5, initialize6 };

RuntimePhases = {
/*{{{*/
updateNMDADepPlasticity, solveChannels, predictJunction,
#if MAX_COMPUTE_ORDER>6
      forwardSolve7,
#endif
#if MAX_COMPUTE_ORDER>5  
      forwardSolve6,
#endif
#if MAX_COMPUTE_ORDER>4
      forwardSolve5,  
#endif
#if MAX_COMPUTE_ORDER>3
      forwardSolve4,
#endif
#if MAX_COMPUTE_ORDER>2
      forwardSolve3,
#endif
#if MAX_COMPUTE_ORDER>1
      forwardSolve2,
#endif
#if MAX_COMPUTE_ORDER>0 
      forwardSolve1,
#endif
      solve, 
#if MAX_COMPUTE_ORDER>0 
      backwardSolve1,
#endif
#if MAX_COMPUTE_ORDER>1
      backwardSolve2,
#endif  
#if MAX_COMPUTE_ORDER>2
      backwardSolve3,
#endif
#if MAX_COMPUTE_ORDER>3 
      backwardSolve4,
#endif
#if MAX_COMPUTE_ORDER>4
      backwardSolve5,
#endif
#if MAX_COMPUTE_ORDER>5
      backwardSolve6,
#endif
#if MAX_COMPUTE_ORDER>6
      backwardSolve7,
#endif
      correctJunction, finish
/*}}}*/
 };

FinalPhases = { finalize };
/*}}}*/

//GRANULE MAPPER DEFINITION
// a. declaration
// b. instantiation
GranuleMapper GridGranuleMapper(string description, list<int> dimensions, list<int> densityVector);
GridGranuleMapper tissueGM("Tissue Grid's GridGranuleMapper", { _X_ , _Y_ , _Z_ }, {1});

//TISSUE FUNCTOR
/*{{{*/
//FUNCTORS DEFINITION
Layout TissueLayoutFunctor();
TissueLayoutFunctor tissueLayoutFunctor();    

NodeInitializer TissueNodeInitFunctor();
TissueNodeInitFunctor tissueNodeInitFunctor();

Connector TissueConnectorFunctor();
TissueConnectorFunctor tissueConnectorFunctor();

Functor TissueProbeFunctor();
TissueProbeFunctor tissueProbeFunctor();
//TISSUEFUNCTOR DEFINITION
Functor TissueFunctor(string commandLine, string commandLineModification, 
		string channelParamaterFile, string synapseParameteurFile,
		Functor, Functor, Functor, Functor, int compartmentSize);
#define strArg1 "neurons.txt -p params/DevParams.par"
#define strArg1_supplement "-p params/DetParams.par -n cost-volume"
#define strArg3 "params/ChanParams-Wolf2005.par"
#if SIMULATION_INVOLVE == VMONLY
#define  strArg2 "params/CptParams.par"
#define  strArg4 "params/SynParams.par"
#elif SIMULATION_INVOLVE == VM_CACYTO
#define  strArg2 "params/CptParams-VmCai.par"
#define  strArg4 "params/SynParams-VmCai.par"
#elif SIMULATION_INVOLVE == VM_CACYTO_CAER || SIMULATION_INVOLVE == VM_CACYTO_CAER_DOPA
#define  strArg2 "params/CptParams-VmCaiCaER.par"
#define  strArg4 "params/SynParams-VmCaiCaER.par"
#endif
TissueFunctor  tissueFunctor(strArg1,
		strArg1_supplement,
		strArg2,
		strArg3,
		strArg4,
		tissueLayoutFunctor, tissueNodeInitFunctor, tissueConnectorFunctor,
		tissueProbeFunctor
		);
/*}}}*/

//NODETYPE DEFINITION
/*{{{*/
// 1. BRANCH NODE + JUNCTION NODE
/*{{{*/
//   1.0. - Compute Nodes
/*{{{*/
#if MAX_COMPUTE_ORDER>0
NodeType BackwardSolvePoint0 { produceInitialState->initialize1,
        produceBackwardSolution->solve };
NodeType ForwardSolvePoint1 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve1 };
#endif

#if MAX_COMPUTE_ORDER>1
NodeType BackwardSolvePoint1 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve1 };
NodeType ForwardSolvePoint2 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve2 };
#endif

#if MAX_COMPUTE_ORDER>2
NodeType BackwardSolvePoint2 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve2 };
NodeType ForwardSolvePoint3 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve3 };
#endif
  
#if MAX_COMPUTE_ORDER>3

NodeType BackwardSolvePoint3 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve3 };
NodeType ForwardSolvePoint4 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve4 };
#endif

#if MAX_COMPUTE_ORDER>4
NodeType BackwardSolvePoint4 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve4 };
NodeType ForwardSolvePoint5 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve5 };
#endif

#if MAX_COMPUTE_ORDER>5
NodeType BackwardSolvePoint5 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve5 };
NodeType ForwardSolvePoint6 { produceInitialState->initialize1,
          produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve6 };
#endif

#if MAX_COMPUTE_ORDER>6
NodeType BackwardSolvePoint6 { produceInitialState->initialize1,
        produceBackwardSolution->backwardSolve6 };
NodeType ForwardSolvePoint7 { produceInitialState->initialize1,
        produceInitialCoefficients->initialize2,
        produceForwardSolution->forwardSolve7 };
#endif

/*}}}*/
//   1.1. - Voltage
/*{{{*/
NodeType HodgkinHuxleyVoltage( <
      Ra= Ra_value,      // Gohm*um
      Na= Na_i_value,          // mM
      K= K_i_value,            // mM 
      E_leak= E_leak_value        // mV
           >) { initializeCompartmentData->initialize2 };
NodeType HodgkinHuxleyVoltageJunction (<
      Ra= Ra_value,       // Gohm*um
      Na= Na_i_value,        // mM
      K= K_i_value,        // mM 
      E_leak= E_leak_value    // mV
        >) { initializeJunction->initialize2 };//NOTE: there is no need for name-mapping for 
                             //junctionPoint() RuntimePhase's kernels 
                            //(only mapping if the name is different from what defined in GSL's xxxPhases) 

NodeType VoltageEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedVoltage-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedVoltage->solve,
#endif
        produceFinishedVoltage->finish
      };
NodeType VoltageJunctionPoint { 
        produceInitialState->initialize1, produceVoltage->predictJunction 
      };
/*}}}*/
//   1.2. - [Ca]intracellular
/*{{{*/
#if SIMULATION_INVOLVE == VM_CACYTO
NodeType CaConcentration (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA, // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
           >) { initializeCompartmentData->initialize2, deriveParameters->initialize2 };

NodeType CaConcentrationEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedCaConcentration-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedCaConcentration->solve,
#endif
        produceFinishedCaConcentration->finish
      };
NodeType CaConcentrationJunction (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA,  // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
        >) { deriveParameters->initialize2, initializeJunction->initialize2 };
NodeType CaConcentrationJunctionPoint { 
         produceInitialState->initialize1, produceCaConcentration->predictJunction };
#endif
/*}}}*/
//   1.3. - [Ca]ER
/*{{{*/
#if SIMULATION_INVOLVE == VM_CACYTO_CAER
NodeType CaERConcentration (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA, // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
           >) { initializeCaConcentration->initialize2, deriveParameters->initialize2 };

NodeType CaERConcentrationEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedCaConcentration-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedCaConcentration->solve,
#endif
        produceFinishedCaConcentration->finish
      };
NodeType CaERConcentrationJunction (<
                        DCa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA,  // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=CA_BASELINE      // uM
        >) { deriveParameters->initialize2, initializeJunction->initialize2 };
NodeType CaERConcentrationJunctionPoint { 
         produceInitialState->initialize1, produceCaConcentration->predictJunction };

#endif
/*}}}*/
//   1.4. - [Dopamine]extracellular
/*{{{*/
#if SIMULATION_INVOLVE == VM_CACYTO_CAER_DOPA 
NodeType DopamineConcentration (<
                        DiffDA=DiffDA_value,                 // um^2/ms unbuffered
                        beta=BETA_Dopamine_value, // dimensionless, Wagner and Keizer buffering constant
                        CaBaseline=DA_o_value      // ???uM
           >) { initializeCaConcentration->initialize2, deriveParameters->initialize2 };

NodeType DopamineConcentrationEndPoint { produceInitialState->initialize1,
#if MAX_COMPUTE_ORDER>0
        produceSolvedDopaConcentration-> CCAT(backwardSolve,MAX_COMPUTE_ORDER),
#else
        produceSolvedDopaConcentration->solve,
#endif
        produceFinishedDopaConcentration->finish
      };
NodeType DopamineConcentrationJunction (<
                        DDopa=CA_DCA,                 // um^2/ms unbuffered
                        beta=CA_BETA,  // dimensionless, Wagner and Keizer buffering constant
                        DopaBaseline=CA_BASELINE      // uM
        >) { deriveParameters->initialize2, initializeJunction->initialize2 };
NodeType DopamineConcentrationJunctionPoint { 
         produceInitialState->initialize1, produceDopaConcentration->predictJunction };
#endif
/*}}}*/
/*}}}*/

// 2. RECEPTOR/CHANNEL NODE
/*{{{*/
//Na+ currents
/*{{{*/
   /* Fast-inactivating (transient) Na+ */
NodeType ChannelNat {computeE->initialize2, initialize->initialize3, update->solveChannels};
   /* Persistent Na+ current */
NodeType ChannelNap {computeE->initialize2, initialize->initialize3, update->solveChannels};
/*}}}*/
//K+ currents
/*{{{*/
  /* KAf - fast-inactivating 'A'-type K+ Kv4.2 data */
NodeType ChannelKAf { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* KAs - slow-inactivating 'A'-type K+ Kv1.2 data */
NodeType ChannelKAs { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* KRP 4-AP resistent persistent K+ current */
NodeType ChannelKRP { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* KIR - inward-rectifying K+  */
NodeType ChannelKIR { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* large-conductance BK Ca2+-dependent K+ current */
  /* type-I alpha+beta subunits: fast-activating + inactivating */
NodeType ChannelBKalphabeta { computeE->initialize2, initialize->initialize3, update->solveChannels };
  /* small-conductance SK Ca2+-dependent K+ current */
  /* SK only present on secondary and tertary dendrites only */
NodeType ChannelSK { computeE->initialize2, initialize->initialize3, update->solveChannels };
/*}}}*/
//Ca2+ currents
/*{{{*/
  /* N-type Ca2+ Cav2.2 (high-voltaged activated) */
NodeType ChannelCaN { initialize->initialize3, update->solveChannels };
  /* P/Q-type Ca2+ Cav2.1 (high-voltaged activated) */
NodeType ChannelCaPQ { initialize->initialize3, update->solveChannels };
  /* R-type Ca2+ Cav2.3 (high-voltaged activated) */
NodeType ChannelCaR { initialize->initialize3, update->solveChannels };
  /* NOTE: L-type Cav1.1, Cav1.2, Cav1.3, Cav1.4 */
  /* L-type Ca2+ Cav1.2 and Cav1.3 (high-voltage activated)*/
//NodeType ChannelCaL { initialize->initialize3, update->solveChannels };
NodeType ChannelCaLv12 { initialize->initialize3, update->solveChannels };
NodeType ChannelCaLv13 { initialize->initialize3, update->solveChannels };
  /* T-type Ca2+ (low-voltage activated)*/
NodeType ChannelCaT { initialize->initialize3, update->solveChannels };
/*}}}*/
#if SIMULATION_INVOLVE == VM_CACYTO_CAER
//RYR
//IP3R
#endif
/*}}}*/
// 2.1. PUMPS 
/*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO
// PMCA
// NCX
#endif
#if SIMULATION_INVOLVE == VM_CACYTO_CAER
// SERCA
#endif
/*}}}*/

// 3. SYNAPSE
/*{{{*/
// 3.1. CHEMICAL SYNAPSE RECEPTOR
/*{{{*/
NodeType AMPAReceptor (<
          E=0.0,        // mV
          alpha=0.05, // uM^-1 msec^-1
          beta=2.0,    // msec^1
          NTmax=180,     // 160-190 uM
          Vp=2.0,       // mV
          Kp=5.0        // mV
          >) { initializeAMPA->initialize3, updateAMPA->solveChannels };
NodeType NMDAReceptor (<
          E = 0.0,       // mV
          alpha=0.000512,  // uM^-1 msec^-1
          beta=0.053,     // msec^1
          NTmax=180,      // 160-190 uM
          Vp=2.0,        // mV
          Kp=5.0,        // mV
          plasticityOn = 0,
          plasticityStartAt = 0, //ms
          plasticityStopAt = 100000, //ms
          theta_d = 1.0,
          theta_p = 1.3,
          gamma_d = 100, // 331.9,
          gamma_p = 125, // 725.085,
          tau = 34600.3615, //ms
          w_th = 0.5,
          deltaNMDAR = 0, // Turns on/off changes in NMDARs
          alphaBuffer = 0.0175,
          tauBuffer = 3000
 >) { initializeNMDA->initialize3, updateNMDA->solveChannels };
NodeType GABAAReceptor (<
          E=-80.0,      // mV
          alpha=0.005,  // uM^-1 msec^-1
          beta=0.18,    // msec^1
          NTmax=185,     // 185 uM
          Vp=2.0,       // mV
          Kp=5.0        // mV
          >) { initializeGABAA->initialize3, updateGABAA->solveChannels };
/*}}}*/
// 3.2. PRE-SYNAPSE NODE
/*{{{*/
NodeType PreSynapticPoint { produceInitialState->initialize2, produceState->finish };
/*}}}*/

// 3.3 CONNECXON - connecting a spine (2-compartment neuron) - with a branch
/*{{{*/
#if SIMULATION_INVOLVE == VMONLY
NodeType SpineAttachment_Vm { produceInitialVoltage->initialize2, produceVoltage->finish, computeState->solveChannels };
#elif SIMULATION_INVOLVE == VM_CACYTO
NodeType SpineAttachment_VmCai { produceInitialState->initialize2, produceState->finish, computeState->solveChannels };
#elif SIMULATION_INVOLVE == VM_CACYTO_CAER || SIMULATION_INVOLVE == VM_CACYTO_CAER_DOPA
NodeType SpineAttachment_VmCaiCaER { produceInitialState->initialize2, produceState->finish, computeState->solveChannels };
#endif
/*}}}*/
/*}}}*/

// 4. CONSTANT [no need to change, modify SECTIONZ]
/*{{{*/
ConstantType ExtracellularMedium;
ExtracellularMedium extracellularMedium<  Na=Na_o_value,  // [mM]
                                          K=K_o_value,    //[mM]
                                          T= Temperature_value,     // degK
                                          Ca=Ca_o_value,  // uM
                                          Mg=Mg_o_value>;   // uM
ConstantType TimeStep;
TimeStep timeStep< deltaT=TimeStep_value >; // msec
/*}}}*/
// 5. TRIGGER
/*{{{*/
Trigger UnsignedTrigger(string description, Service svc, string operator, int criterion, int delay, string phaseName);
Trigger CompositeTrigger(string description, Trigger triggerA, int critA, string operator, Trigger triggerB, int critB, int delay, string phaseName);

UnsignedTrigger recOn("Iteration Trigger : !% " STR(RecordInterval), 
          ::Iteration, "!%", RecordInterval, 0, solveChannels ); //Record every ms
/*}}}*/

// 6. VARIABLES (stimulus, I/O)
/*{{{*/
//stimulus
//{{{
VariableType CurrentPulseGenerator { initialize->initialize1, update->solveChannels };
CurrentPulseGenerator synapseStimInj0<pattern="periodic", peak=0.1, duration=1, delay=200, period=600, last=3600, inc=0>;
CurrentPulseGenerator currentStimInj0<pattern="periodic", peak=2000, duration=3, period=620, delay=1785, last=3600, inc=0>; 
polyConnect(timeStep, currentStimInj0, <>, <>);
CurrentPulseGenerator currentStimInj1<pattern="periodic", peak=2000, duration=3, period=5000, delay=400, last=3600, inc=0>; 
polyConnect(timeStep, currentStimInj1, <>, <>);
//}}}

//I/O purpose
//{{{
VariableType VoltageDisplay{ initialize->initialize1 };
VoltageDisplay voltageDisplay<fileName="out/somaV.dat">;
voltageDisplay.dataCollection(<>) on recOn;

VariableType CalciumDisplay{ initialize->initialize4 };
CalciumDisplay calciumSomaDisplay<fileName="out/somaCa.dat">;
calciumSomaDisplay.dataCollection(<>) on recOn;

VoltageDisplay synapseVoltageDisplay0<fileName="out/synapseV0.dat">;
synapseVoltageDisplay0.dataCollection(<>) on recOn;
CalciumDisplay synapseCalciumDisplay0<fileName="out/synapseC0.dat">;
synapseCalciumDisplay0.dataCollection(<>) on recOn;
//}}}
/*}}}*/
/*}}}*/


Struct TissueSite;
//GRID DEFINITION
//MSN D1-like neuron
Grid MSN_D1Neuron{
/*{{{*/

	// GRID DIMENSION
	//_X_*_Y_*_Z_ = # processes in MPI
	// i.e. each volume is handled by one process
	Dimension( _X_, _Y_, _Z_ );

	// GRID LAYER
	//LAYER(name_of_layer, NodesAssociatedWithTheGivenLayer |
	//                     ConstantAssociatedWithTheGivenlayer |
	//                     VariableAssociatedWithTheGivenlayer,
	//     tissueFunctor("Layout", <nodekind="AValueIn") 
	//     )
	/*{{{*/
  	  // 1. LAYER BRANCHES (data as an array)
     /*{{{*/
      //  1.0. - Compute Nodes
      /*{{{*/
#if MAX_COMPUTE_ORDER>0
	Layer(fwdSolvePoints1, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][1]">), <nodekind="ForwardSolvePoints[Voltage][1]">, tissueGM);
	Layer(bwdSolvePoints0, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][0]">), <nodekind="BackwardSolvePoints[Voltage][0]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints1_Ca, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][1]">), <nodekind="ForwardSolvePoints[Calcium][1]">, tissueGM);
	Layer(bwdSolvePoints0_Ca, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][0]">), <nodekind="BackwardSolvePoints[Calcium][0]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints1_CaER, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][1]">), <nodekind="ForwardSolvePoints[CalciumER][1]">, tissueGM);
	Layer(bwdSolvePoints0_CaER, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][0]">), <nodekind="BackwardSolvePoints[CalciumER][0]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints1_Dopa, ForwardSolvePoint1, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][1]">), <nodekind="ForwardSolvePoints[Dopa][1]">, tissueGM);
	Layer(bwdSolvePoints0_Dopa, BackwardSolvePoint0, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][0]">), <nodekind="BackwardSolvePoints[Dopa][0]">, tissueGM);
#endif
#endif
#if MAX_COMPUTE_ORDER>1
	Layer(fwdSolvePoints2, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][2]">), <nodekind="ForwardSolvePoints[Voltage][2]">, tissueGM);
	Layer(bwdSolvePoints1, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][1]">), <nodekind="BackwardSolvePoints[Voltage][1]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints2_Ca, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][2]">), <nodekind="ForwardSolvePoints[Calcium][2]">, tissueGM);
	Layer(bwdSolvePoints1_Ca, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][1]">), <nodekind="BackwardSolvePoints[Calcium][1]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints2_CaER, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][2]">), <nodekind="ForwardSolvePoints[CalciumER][2]">, tissueGM);
#elif 
	Layer(bwdSolvePoints1_CaER, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][1]">), <nodekind="BackwardSolvePoints[CalciumER][1]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints2_Dopa, ForwardSolvePoint2, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][2]">), <nodekind="ForwardSolvePoints[Dopa][2]">, tissueGM);
	Layer(bwdSolvePoints1_Dopa, BackwardSolvePoint1, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][1]">), <nodekind="BackwardSolvePoints[Dopa][1]">, tissueGM);
#endif
#endif
#if MAX_COMPUTE_ORDER>2
	Layer(fwdSolvePoints3, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][3]">), <nodekind="ForwardSolvePoints[Voltage][3]">, tissueGM);
	Layer(bwdSolvePoints2, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][2]">), <nodekind="BackwardSolvePoints[Voltage][2]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints3_Ca, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][3]">), <nodekind="ForwardSolvePoints[Calcium][3]">, tissueGM);
	Layer(bwdSolvePoints2_Ca, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][2]">), <nodekind="BackwardSolvePoints[Calcium][2]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints3_CaER, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][3]">), <nodekind="ForwardSolvePoints[CalciumER][3]">, tissueGM);
	Layer(bwdSolvePoints2_CaER, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][2]">), <nodekind="BackwardSolvePoints[CalciumER][2]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints3_Dopa, ForwardSolvePoint3, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][3]">), <nodekind="ForwardSolvePoints[Dopa][3]">, tissueGM);
	Layer(bwdSolvePoints2_Dopa, BackwardSolvePoint2, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][2]">), <nodekind="BackwardSolvePoints[Dopa][2]">, tissueGM);
#endif
#endif
#if MAX_COMPUTE_ORDER>3
	Layer(fwdSolvePoints4, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][4]">), <nodekind="ForwardSolvePoints[Voltage][4]">, tissueGM);
	Layer(bwdSolvePoints3, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][3]">), <nodekind="BackwardSolvePoints[Voltage][3]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints4_Ca, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][4]">), <nodekind="ForwardSolvePoints[Calcium][4]">, tissueGM);
	Layer(bwdSolvePoints3_Ca, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][3]">), <nodekind="BackwardSolvePoints[Calcium][3]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints4_CaER, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][4]">), <nodekind="ForwardSolvePoints[CalciumER][4]">, tissueGM);
	Layer(bwdSolvePoints3_CaER, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][3]">), <nodekind="BackwardSolvePoints[CalciumER][3]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints4_Dopa, ForwardSolvePoint4, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][4]">), <nodekind="ForwardSolvePoints[Dopa][4]">, tissueGM);
	Layer(bwdSolvePoints3_Dopa, BackwardSolvePoint3, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][3]">), <nodekind="BackwardSolvePoints[Dopa][3]">, tissueGM);
#endif
#endif
#if MAX_COMPUTE_ORDER>4
	Layer(fwdSolvePoints5, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][5]">), <nodekind="ForwardSolvePoints[Voltage][5]">, tissueGM);
	Layer(bwdSolvePoints4, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][4]">), <nodekind="BackwardSolvePoints[Voltage][4]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints5_Ca, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][5]">), <nodekind="ForwardSolvePoints[Calcium][5]">, tissueGM);
	Layer(bwdSolvePoints4_Ca, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][4]">), <nodekind="BackwardSolvePoints[Calcium][4]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints5_CaER, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][5]">), <nodekind="ForwardSolvePoints[CalciumER][5]">, tissueGM);
	Layer(bwdSolvePoints4_CaER, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][4]">), <nodekind="BackwardSolvePoints[CalciumER][4]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints5_Dopa, ForwardSolvePoint5, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][5]">), <nodekind="ForwardSolvePoints[Dopa][5]">, tissueGM);
	Layer(bwdSolvePoints4_Dopa, BackwardSolvePoint4, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][4]">), <nodekind="BackwardSolvePoints[Dopa][4]">, tissueGM);
#endif
#endif
#if MAX_COMPUTE_ORDER>5
	Layer(fwdSolvePoints6, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][6]">), <nodekind="ForwardSolvePoints[Voltage][6]">, tissueGM);
	Layer(bwdSolvePoints5, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][5]">), <nodekind="BackwardSolvePoints[Voltage][5]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints6_Ca, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][6]">), <nodekind="ForwardSolvePoints[Calcium][6]">, tissueGM);
	Layer(bwdSolvePoints5_Ca, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][5]">), <nodekind="BackwardSolvePoints[Calcium][5]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints6_CaER, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][6]">), <nodekind="ForwardSolvePoints[CalciumER][6]">, tissueGM);
	Layer(bwdSolvePoints5_CaER, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][5]">), <nodekind="BackwardSolvePoints[CalciumER][5]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints6_Dopa, ForwardSolvePoint6, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][6]">), <nodekind="ForwardSolvePoints[Dopa][6]">, tissueGM);
	Layer(bwdSolvePoints5_Dopa, BackwardSolvePoint5, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][5]">), <nodekind="BackwardSolvePoints[Dopa][5]">, tissueGM);
#endif
#endif
#if MAX_COMPUTE_ORDER>6
	Layer(fwdSolvePoints7, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Voltage][7]">), <nodekind="ForwardSolvePoints[Voltage][7]">, tissueGM);
	Layer(bwdSolvePoints6, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Voltage][6]">), <nodekind="BackwardSolvePoints[Voltage][6]">, tissueGM);
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(fwdSolvePoints7_Ca, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Calcium][7]">), <nodekind="ForwardSolvePoints[Calcium][7]">, tissueGM);
	Layer(bwdSolvePoints6_Ca, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Calcium][6]">), <nodekind="BackwardSolvePoints[Calcium][6]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(fwdSolvePoints7_CaER, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[CalciumER][7]">), <nodekind="ForwardSolvePoints[CalciumER][7]">, tissueGM);
	Layer(bwdSolvePoints6_CaER, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[CalciumER][6]">), <nodekind="BackwardSolvePoints[CalciumER][6]">, tissueGM);
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	Layer(fwdSolvePoints7_Dopa, ForwardSolvePoint7, tissueFunctor("Layout", <nodekind="ForwardSolvePoints[Dopa][7]">), <nodekind="ForwardSolvePoints[Dopa][7]">, tissueGM);
	Layer(bwdSolvePoints6_Dopa, BackwardSolvePoint6, tissueFunctor("Layout", <nodekind="BackwardSolvePoints[Dopa][6]">), <nodekind="BackwardSolvePoints[Dopa][6]">, tissueGM);
#endif
#endif
      /*}}}*/
      
      //  1.1. - Voltage
	// NOTE: branches = a collection of branches, each branch is a multiple compartments variables
    //       endPoints = a collection of endPoint, each endPoint is treated as a single-compartment branch with data reference to the end-compartment of a branch
    //       junctions = a collection of junction, each is a single-compartment 
    //       junctionPoints = a collection of junctionPoint, each is a single-compartment reference to end-compartment of a junction
      /*{{{*/
	Layer(branches, HodgkinHuxleyVoltage, tissueFunctor("Layout", <nodekind="CompartmentVariables[Voltage]">), <nodekind="CompartmentVariables[Voltage]">, tissueGM);
	Layer(endPoints, VoltageEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[Voltage]">), <nodekind="EndPoints[Voltage]">, tissueGM);
    Layer(junctions, HodgkinHuxleyVoltageJunction, tissueFunctor("Layout", <nodekind="Junctions[Voltage]">), <nodekind="Junctions[Voltage]">, tissueGM);
    Layer(junctionPoints, VoltageJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[Voltage]">), <nodekind="JunctionPoints[Voltage]">, tissueGM);
      /*}}}*/
      //  1.2. - [Ca]intracellular
      /*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO
	Layer(branches_Ca, CaConcentration, tissueFunctor("Layout", <nodekind="CompartmentVariables[Calcium]">), <nodekind="CompartmentVariables[Calcium]">, tissueGM);
	Layer(endPoints_Ca, CaConcentrationEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[Calcium]">), <nodekind="EndPoints[Calcium]">, tissueGM);
    Layer(junctions_Ca, CaConcentrationJunction, tissueFunctor("Layout", <nodekind="Junctions[Calcium]">), <nodekind="Junctions[Calcium]">, tissueGM);
	Layer(junctionPoints_Ca, CaConcentrationJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[Calcium]">), <nodekind="JunctionPoints[Calcium]">, tissueGM);
#endif
      /*}}}*/
      //  1.3. - [Ca]ER
      /*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(branches_CaER, CaERConcentration, tissueFunctor("Layout", <nodekind="CompartmentVariables[CalciumER]">), <nodekind="CompartmentVariables[CalciumER]">, tissueGM);
	Layer(endPoints_CaER, CaERConcentrationEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[CalciumER]">), <nodekind="EndPoints[CalciumER]">, tissueGM);
    Layer(junctions_CaER, CaERConcentrationJunction, tissueFunctor("Layout", <nodekind="Junctions[CalciumER]">), <nodekind="Junctions[CalciumER]">, tissueGM);
	Layer(junctionPoints_CaER, CaERConcentrationJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[CalciumER]">), <nodekind="JunctionPoints[CalciumER]">, tissueGM);
#endif
      /*}}}*/
      //  1.4. - [Dopamine]extracellular
      /*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	Layer(branches_Dopa, DopaConcentration, tissueFunctor("Layout", <nodekind="CompartmentVariables[Dopa]">), <nodekind="CompartmentVariables[Dopa]">, tissueGM);
	Layer(endPoints_Dopa, DopaConcentrationEndPoint, tissueFunctor("Layout", <nodekind="EndPoints[Dopa]">), <nodekind="EndPoints[Dopa]">, tissueGM);
    Layer(junctions_Dopa, DopaConcentrationJunction, tissueFunctor("Layout", <nodekind="Junctions[Dopa]">), <nodekind="Junctions[Dopa]">, tissueGM);
	Layer(junctionPoints_Dopa, DopaConcentrationJunctionPoint, tissueFunctor("Layout", <nodekind="JunctionPoints[Dopa]">), <nodekind="JunctionPoints[Dopa]">, tissueGM);
#endif
      /*}}}*/

    /*}}}*/
      // 2. RECEPTOR/CHANNEL    
	/*{{{*/
     //{{{ Na channels
	Layer(NatChannels, ChannelNat, tissueFunctor("Layout", < nodekind="Channels[Nat]" >), < nodekind="Channels[Nat]" >, tissueGM);
	Layer(NapChannels, ChannelNap, tissueFunctor("Layout", < nodekind="Channels[Nap]" >), < nodekind="Channels[Nap]" >, tissueGM);
     //}}}
     //{{{ K+ channels
	Layer(KAfChannels, ChannelKAf, tissueFunctor("Layout", < nodekind="Channels[KAf]" >), < nodekind="Channels[KAf]" >, tissueGM);
	Layer(KAsChannels, ChannelKAs, tissueFunctor("Layout", < nodekind="Channels[KAs]" >), < nodekind="Channels[KAs]" >, tissueGM);
	Layer(KRPChannels, ChannelKRP, tissueFunctor("Layout", < nodekind="Channels[KRP]" >), < nodekind="Channels[KRP]" >, tissueGM);
	Layer(KIRChannels, ChannelKIR, tissueFunctor("Layout", < nodekind="Channels[KIR]" >), < nodekind="Channels[KIR]" >, tissueGM);
	Layer( BKalphabetaChannels, ChannelBKalphabeta,  tissueFunctor("Layout", < nodekind="Channels[BK]" >), < nodekind="Channels[BK]" >, tissueGM);
	Layer( SKChannels, ChannelSK,  tissueFunctor("Layout", < nodekind="Channels[SK]" >), < nodekind="Channels[SK]" >, tissueGM);
     //}}}
    //{{{ Ca2+ channels
	Layer(CaLv12Channels, ChannelCaLv12_GHK, tissueFunctor("Layout", < nodekind="Channels[CaLv12]" >), < nodekind="Channels[CaLv12]" >, tissueGM);
	Layer(CaLv13Channels, ChannelCaKv13_GHK, tissueFunctor("Layout", < nodekind="Channels[CaLv13]" >), < nodekind="Channels[CaLv13]" >, tissueGM);
	Layer(CaNChannels, ChannelCaN_GHK, tissueFunctor("Layout", < nodekind="Channels[CaN]" >), < nodekind="Channels[CaN]" >, tissueGM);
	Layer(CaPQChannels, ChannelCaPQ_GHK, tissueFunctor("Layout", < nodekind="Channels[CaPQ]" >), < nodekind="Channels[CaPQ]" >, tissueGM);
	Layer(CaRChannels, ChannelCaR_GHK, tissueFunctor("Layout", < nodekind="Channels[CaR]" >), < nodekind="Channels[CaR]" >, tissueGM);
	Layer(CaTChannels, ChannelCaT_GHK, tissueFunctor("Layout", < nodekind="Channels[CaT]" >), < nodekind="Channels[CaT]" >, tissueGM);
     //}}}
	/*}}}*/
      // 3. SYNAPSES
      /*{{{*/
      // 3.1. CHEMICAL SYNAPSE RECEPTORS
      /*{{{*/
	Layer(AMPASynapses, AMPAReceptor, tissueFunctor("Layout", < nodekind="ChemicalSynapses[AMPA]" >), < nodekind="ChemicalSynapses[AMPA]" >, tissueGM);
	Layer(NMDASynapses, NMDAReceptor, tissueFunctor("Layout", < nodekind="ChemicalSynapses[NMDA]" >), < nodekind="ChemicalSynapses[NMDA]" >, tissueGM);
	Layer(GABAASynapses, GABAAReceptor, tissueFunctor("Layout", < nodekind="ChemicalSynapses[GABAA]" >), < nodekind="ChemicalSynapses[GABAA]" >, tissueGM);
      /*}}}*/
      // 3.2. PRE-SYNAPSE (get Voltage from bouton-side)
	/*{{{*/
// TODO: If we want to use neurotransmitter concentration, what is the best strategy? to map through pre-synaptic voltage?
	Layer(PreSynapticPoints, PreSynapticPoint, tissueFunctor("Layout", < nodekind="PreSynapticPoints[Voltage]" >), < nodekind="PreSynapticPoints[Voltage]" >, tissueGM);
	/*}}}*/
      // 3.3. SpineAttachment
	/*{{{*/
#if SIMULATION_INVOLVE == VMONLY
	Layer(DendriticSpines, SpineAttachment_Vm, tissueFunctor("Layout", < nodekind="BidirectionalConnections[DenSpine]" >), < nodekind="BidirectionalConnections[DenSpine]" >, tissueGM);
#elif SIMULATION_INVOLVE == VM_CACYTO
	Layer(DendriticSpines, SpineAttachment_VmCai, tissueFunctor("Layout", < nodekind="BidirectionalConnections[DenSpine]" >), < nodekind="BidirectionalConnections[DenSpine]" >, tissueGM);
#elif SIMULATION_INVOLVE == VM_CACYTO_CAER || SIMULATION_INVOLVE == VM_CACYTO_CAER_DOPA
	Layer(DendriticSpines, SpineAttachment_VmCaiCaER, tissueFunctor("Layout", < nodekind="BidirectionalConnections[DenSpine]" >), < nodekind="BidirectionalConnections[DenSpine]" >, tissueGM);
#endif
	/*}}}*/
      // 4. CONNECXON (gap-junction)
      /*{{{*/
   Layer(AxoAxonicGapJunctions, Connexon, tissueFunctor("Layout", < nodekind="ElectricalSynapses[AxAxGap]" >), < nodekind="ElectricalSynapses[AxAxGap]" >, tissueGM);
   Layer(DendroDendriticGapJunctions, Connexon, tissueFunctor("Layout", < nodekind="ElectricalSynapses[DenDenGap]" >), < nodekind="ElectricalSynapses[DenDenGap]" >, tissueGM);
      /*}}}*/
     /*}}}*/

	/*}}}*/

	// GRID - INIT NODES
	/*{{{*/
	// 1. BRANCHES NODES
	/*{{{*/
    // 1.0 - Compute  (all branches nodetypes) [no need to change]
	/*{{{*/
#if MAX_COMPUTE_ORDER>0
	InitNodes ( .[].Layer(fwdSolvePoints1), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints0), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints1_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints0_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints1_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints0_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints1_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints0_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
#if MAX_COMPUTE_ORDER>1
	InitNodes ( .[].Layer(fwdSolvePoints2), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints1), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints2_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints1_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints2_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints1_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints2_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints1_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
#if MAX_COMPUTE_ORDER>2
	InitNodes ( .[].Layer(fwdSolvePoints3), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints2), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints3_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints2_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints3_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints2_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints3_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints2_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
#if MAX_COMPUTE_ORDER>3
	InitNodes ( .[].Layer(fwdSolvePoints4), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints3), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints4_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints3_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints4_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints3_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints4_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints3_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
#if MAX_COMPUTE_ORDER>4
	InitNodes ( .[].Layer(fwdSolvePoints5), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints4), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints5_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints4_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints5_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints4_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints5_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints4_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
#if MAX_COMPUTE_ORDER>5
	InitNodes ( .[].Layer(fwdSolvePoints6), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints5), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints6_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints5_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints6_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints5_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints6_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints5_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
#if MAX_COMPUTE_ORDER>6
	InitNodes ( .[].Layer(fwdSolvePoints7), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints6), tissueFunctor("NodeInit", <> ) );
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(fwdSolvePoints7_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints6_Ca), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(fwdSolvePoints7_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints6_CaER), tissueFunctor("NodeInit", <> ) );
#endif
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(fwdSolvePoints7_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(bwdSolvePoints6_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
#endif
    /*}}}*/
    // 1.1. - Voltage
    /*{{{*/
	InitNodes ( .[].Layer(branches), tissueFunctor("NodeInit", <
				compartmentalize = { "Vnew", 
				"Vcur", 
				"Aii", 
				"Aim", 
				"Aip", 
				"RHS", 
				},
				Vnew = {Vrest_value}
				> ) );
	InitNodes ( .[].Layer(endPoints), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions), tissueFunctor("NodeInit", < Vnew = {Vrest_value}  > ) );
	InitNodes ( .[].Layer(junctionPoints), tissueFunctor("NodeInit", <> ) );
     /*}}}*/
    // 1.2. - [Ca]intrcellular
    /*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO
	InitNodes ( .[].Layer(branches_Ca), tissueFunctor("NodeInit", <
				compartmentalize = {"Ca_new", 
				"Ca_cur", 
				"currentToConc",
				"Aii",
				"Aim", 
				"Aip", 
				"RHS"
				},
				Ca_new = {Cacyto_value}
				> ) );
	InitNodes ( .[].Layer(endPoints_Ca), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions_Ca), tissueFunctor("NodeInit", < Ca_new = {Cacyto_value} > ) ); 
	InitNodes ( .[].Layer(junctionPoints_Ca), tissueFunctor("NodeInit", <> ) );
#endif
    /*}}}*/
    // 1.3. - [Ca]ER
    /*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER
	InitNodes ( .[].Layer(branches_CaER), tissueFunctor("NodeInit", <
				compartmentalize = {"CaER_new", 
				"CaER_cur", 
				"currentToConc",
				"Aii",
				"Aim", 
				"Aip", 
				"RHS"
				},
				CaER_new = {CaER_value} 
				> ) );
	InitNodes ( .[].Layer(endPoints_CaER), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions_CaER), tissueFunctor("NodeInit", < CaER_new = {CaER_value} > ) ); 
	InitNodes ( .[].Layer(junctionPoints_CaER), tissueFunctor("NodeInit", <> ) );
#endif
    /*}}}*/
    // 1.4. - [Dopamine]extracellular
    /*{{{*/
#if SIMULATION_INVOLVE >= VM_CACYTO_CAER_DOPA
	InitNodes ( .[].Layer(branches_Dopa), tissueFunctor("NodeInit", <
				compartmentalize = {"Dopa_new", 
				"Dopa_cur", 
				"currentToConc",
				"Aii",
				"Aim", 
				"Aip", 
				"RHS"
				},
				Dopa_new = {Dopa_value} 
				> ) );
	InitNodes ( .[].Layer(endPoints_Dopa), tissueFunctor("NodeInit", <> ) );
	InitNodes ( .[].Layer(junctions_Dopa), tissueFunctor("NodeInit", < Dopa_new = {Dopa_value} > ) ); 
	InitNodes ( .[].Layer(junctionPoints_Dopa), tissueFunctor("NodeInit", <> ) );
#endif
    /*}}}*/
    /*}}}*/

	// 2. RECEPTORS/CHANNELS NODES
	/*{{{*/
	//{{{ Na+ channels
	InitNodes ( .[].Layer(NatChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0} 
				> ) ); 

	InitNodes ( .[].Layer(NapChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0} 
				> ) ); 
     //}}}
	 //{{{ K+ channels
	InitNodes ( .[].Layer(KAfChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(KAsChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(KRPChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(KDRChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(BKalphabetaChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(SKChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "gbar" },
				gbar = {0.0}
				> ) );
    //}}}
	//{{{ Ca2+ channels
	InitNodes ( .[].Layer(CaNChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "Pbar" },
				Pbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaPQChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "Pbar" },
				Pbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaRChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "Pbar" },
				Pbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaLv12Channels), tissueFunctor("NodeInit", <
				compartmentalize = { "Pbar" },
				Pbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaLv13Channels), tissueFunctor("NodeInit", <
				compartmentalize = { "Pbar" },
				Pbar = {0.0}
				> ) );
	InitNodes ( .[].Layer(CaTChannels), tissueFunctor("NodeInit", <
				compartmentalize = { "Pbar" },
				Pbar = {0.0}
				> ) );
    //}}}
	/*}}}*/

	// 3. SYNAPSES NODES 
    /*{{{*/ 
    // 3.1. SYNAPSE RECEPTORS
    /*{{{*/
	InitNodes ( .[].Layer(AMPASynapses), tissueFunctor("NodeInit", <
				gbar = 5.0 // 2.2223 nS/um^2
				> ) );

	InitNodes ( .[].Layer(NMDASynapses), tissueFunctor("NodeInit", <
				gbar = 5.0, w = 1.0 // 0.17 0.115 nS/um^2 // 
				> ) );

	InitNodes ( .[].Layer(GABAASynapses), tissueFunctor("NodeInit", <
				gbar = 0.50 // nS/um^2
				> ) );  
    /*}}}*/
    // 3.2. PRE-SYNAPSE
    /*{{{*/
	InitNodes ( .[].Layer(PreSynapticPoints), tissueFunctor("NodeInit", <> ) );
    /*}}}*/
    // 3.3. SpineAttachment 
		//{{{
#if SIMULATION_INVOLVE == VMONLY
    InitNodes ( .[].Layer(DendriticSpines), tissueFunctor("NodeInit", <
				I = 0.0,
				g = 2.0 // nS
				> ) );
#elif SIMULATION_INVOLVE == VM_CACYTO
    InitNodes ( .[].Layer(DendriticSpines), tissueFunctor("NodeInit", <
				I = 0.0,
				Raxial = R_axial // [Gohm.um] 
				I_Cacyto = 0, //TUAN: check this
        RCacytoaxial = R_CACYTO_AXIAL // [Gohm.um]
				> ) );
#elif SIMULATION_INVOLVE == VM_CACYTO_CAER || SIMULATION_INVOLVE == VM_CACYTO_CAER_DOPA
    InitNodes ( .[].Layer(DendriticSpines), tissueFunctor("NodeInit", <
				I = 0.0,
				Raxial = R_axial // [Gohm.um] 
				I_Cacyto = 0, //TUAN: check this
        RCacytoaxial = R_CACYTO_AXIAL // [Gohm.um]
				I_CaER = 0,
        RCaERaxial = R_CAER_AXIAL // [Gohm.um]
				> ) );
#endif
     //}}}
    // 4. CONNECXON 
    /*{{{*/
   InitNodes ( .[].Layer(AxoAxonicGapJunctions), tissueFunctor("NodeInit", <
									I = 0,
									g = 0.0495
								  > ) );
   InitNodes ( .[].Layer(DendroDendriticGapJunctions), tissueFunctor("NodeInit", <
									I = 0,
									g = 1.0
								  > ) );
    /*}}}*/
	/*}}}*/
    /*}}}*/

	// GRID - CONNECT LAYERS with ...
    /*{{{*/
	// 1. with CONSTANTS
	/*{{{*/
	polyConnect(timeStep, .[].Layer(branches, junctions), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(branches_Ca, junctions_Ca), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(branches_CaER, junctions_CaER), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(NatChannels, NapChannels), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(KAfChannels, KAsChannels, KRPChannels, BKalphabetaChannels, SKChannels, KDRChannels), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(CaNChannels, CaPQChannels, CaRChannels, CaLv12Channels, CaLv13Channels, CaTChannels), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(AMPASynapses), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(NMDASynapses), <>, <identifier="dt">);
	polyConnect(timeStep, .[].Layer(GABAASynapses), <>, <identifier="dt">);

	polyConnect(extracellularMedium, .[].Layer(NatChannels, NapChannels), <>, <identifier="EC">);
	polyConnect(extracellularMedium, .[].Layer(KAfChannels, KAsChannels, KRPChannels, BKalphabetaChannels, SKChannels, KDRChannels), <>, <identifier="dt">);
	polyConnect(extracellularMedium, .[].Layer(CaNChannels, CaPQChannels, CaRChannels, CaLv12Channels, CaLv13Channels, CaTChannels), <>, <identifier="dt">);
	polyConnect(extracellularMedium, .[].Layer(NMDASynapses), <>, <identifier="EC">);
	polyConnect(extracellularMedium, .[].Layer(AMPASynapses), <>, <identifier="EC">);
	polyConnect(extracellularMedium, .[].Layer(GABASynapses), <>, <identifier="EC">);
	polyConnect(extracellularMedium, .[].Layer(DendriticSpines), <>, <identifier="EC">);
	/*}}}*/

    //IMPORTANT: call this once you already have all Layers with NodeTypes required for the simulation
    tissueFunctor("Connect", <> );  // This is important to perform connections

    // 2. with VARIABLES (for I/O, stimulus)
	/*{{{*/
	polyConnect(timeStep, synapseStimInj0, <>, <>);
	polyConnect(synapseStimInj0, tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", BRANCHORDER=0, NEURON_INDEX=1>), <>, <identifier="stimulation">);

	TissueSite synapseSite0( -41.813584824468236, 175.47049244293586, -0.6457233469214552, 5.0 );

	polyConnect(timeStep, synapseVoltageDisplay0, <>, <>);
	polyConnect(tissueFunctor("Probe", <CATEGORY="BRANCH", TYPE="Voltage", NEURON_INDEX=0>), synapseVoltageDisplay0, <>, <site=synapseSite0>);

	polyConnect(timeStep, synapseCalciumDisplay0, <>, <>);
	polyConnect(tissueFunctor("Probe", <CATEGORY="BRANCH", TYPE="Calcium", NEURON_INDEX=0>), synapseCalciumDisplay0, <>, <site=synapseSite0>);


   TissueSite currentStimSite0( 0, 0, 0, 1.0 );
   polyConnect(currentStimInj0, tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", NEURON_INDEX=0>), <>, <identifier="stimulation", site=currentStimSite0>);

   TissueSite currentStimSite1( 0, 0, 0, 1.0 );
   polyConnect(currentStimInj1, tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", NEURON_INDEX=0>), <>, <identifier="stimulation", site=currentStimSite1>);

   polyConnect(timeStep, voltageDisplay, <>, <>);
   polyConnect( tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Voltage", BRANCHORDER=0>), voltageDisplay, <>, <>);

   polyConnect(timeStep, calciumSomaDisplay, <>, <>);
   polyConnect( tissueFunctor("Probe", <CATEGORY="JUNCTION", TYPE="Calcium", BRANCHORDER=0>), calciumSomaDisplay, <>, <>);

	/*}}}*/

    /*}}}*/

	/*{{{*/
	/*}}}*/
/*}}}*/
}; //end grid

MSN_D1Neuron msn;

  //stop when correctJunction is called for a given number of iterations
UnsignedTrigger endTrig("Iteration Trigger to end or stop", 
		::Iteration, "==", NumIterationsUntilEnd, 0, correctJunction); 

Stop on endTrig;

