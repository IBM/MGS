// =================================================================
// Licensed Materials - Property of IBM
//
// "Restricted Materials of IBM"
//
// BCM-YKT-07-18-2018
//
// (C) Copyright IBM Corp. 2005-2018  All rights reserved
//
// US Government Users Restricted Rights -
// Use, duplication or disclosure restricted by
// GSA ADP Schedule Contract with IBM Corp.
//
// =================================================================

#include "../std/std.gsl"
InitPhases = { init1, init2, initialize };
RuntimePhases = { setContributions, run1, run2, dataCollect, lastPhase };
FinalPhases = { finalize };

#define DIRECTORY "./"
#define FILE_EXTENSION ".dat"
#define DELTA_T 0.0001


// ##### Driving input from cortex #####
// Node parameters

NodeType WaveDriverUnit(<
                        deltaT = DELTA_T,       // in s
                        op_constant = 0
                        >) {update->run1} ;

NodeType FileDriverUnit(<
                        deltaT = DELTA_T,       // in s
			sf = 0.001,
			inputFileName = "HD44_08_Delta_QuietRest_Ctx_zm_cutNeg_std_val1.mat",
                        op_random = 1,
<<<<<<< HEAD:graphs/FSI/FSI.gsl
                        scale = 1.25
=======
                        scale = 0.8 //3.0
>>>>>>> Updated FileDriver output.:graphs/Traub/Traub.gsl
                        >) {initializeShared->init1, readInputFile->run2, updateOutput->run1};

// Connectivity and weights
EachDstPropSrc ctx_2_fsi(RadialSampler(0.5));
BindName CTXw("weight", 1.0, "identifier", "driver");
NdplInAttrInit ctxW(CTXw);

// Initialize waves
#define AMPMIN 1.0
#define AMPMAX 1.5
BindName initWave("Hz", Gaussian(3.0,0.1),
                  "phase", Gaussian(0.0,6.28319), // in rad (360 = 6.28319)
                  "amplitude", UniformDist(AMPMIN, AMPMAX),
                  "wave", UniformDist(AMPMIN, AMPMAX));
NdplNodeInit heterWave(initWave);


// ##### FSI network #####
// Node parameters
NodeType FSIIAFUnit(< 
                      b = 10.0,                // s^-1      
                      GoC = 50.0,              // s^-1
                      C = 1.0,
                      k = {200.0, 20.0},       // s^-1
                      R = {0.0, 1.0},
                      E_L = -0.07,             // V
                      V_r = -0.07,             // V
                      Theta_r = -0.06,         // V
                      a = 0.0,                 // s^-1
                      A = {0.0, 0},            // V/s
                      s_tauR = 0.0008,         // s
                      s_tauF = 0.013,          // s
                      deltaT = DELTA_T,         // s
                      spike_cntMax = 0.001,    // s
                      np = 0,
                      V_max = 0.04,
                      sharedDirectory = DIRECTORY,
                      sharedFileExt = FILE_EXTENSION,
                      op_saveWeights = 1,
                      op_saveGJs = 1,
                      op_savePSPs = 0,
                      op_saveExtra = 0,
                      mu_rho = -1.0, // < 0 is uniform distribution; > 2pi direction is set to same
                      mu_phi = -1.0
                      >) {initializeShared->init2, outputPSPsShared->dataCollect, updateInput->run2, updateV->run1, threshold->run2};

// Synaptic connectivity
list<float> uniformDensity = {1.0};
EachDstPropSrc ipsp_fsi(RadialDensitySampler(72, 2.829, uniformDensity, 2.829));
// (nbrConnections, radius, densityDistribution, boundaryMargin)

// Synaptic weights 
BindName IPSP("weight", Neg(Scale(Exp(RangePassThru(-100,"<=",Gaussian(0.0,1.0),"<=",2.5)),0.375)), "identifier", "ipsp");
NdplInAttrInit ipsp(IPSP);

// Gap junctions connectivity
EachDstPropSrc gj_fsi(Unique(RadialSampler(1.733,2.0)));

// Gap junctions "weights"
BindName GJ1("conductance", 18.0, "identifier", "gj1", "connectionFraction", 0.2263);
BindName GJ2("conductance", 18.0, "identifier", "gj2", "connectionFraction", 0.2263);
NdplInAttrInit gj1(GJ1);
NdplInAttrInit gj2(GJ1);

// Initialize neurons
BindName initN("V", UniformDist(-0.07,-0.05), // Uniform from reset to mean threshold
               "Theta_inf", Neg(Gaussian(0.05,0.001))); // Gaussian around -0.05
NdplNodeInit heterN(initN);



// ##### Setup and connect the graph #####
Grid CTX
{
  Dimension(3,3,3);
  Layer(LayerV, FileDriverUnit, UniformLayout(1), < nodekind="Nodes" >);
  InitNodes(.[].Layer(LayerV), nodeDef);  
};

Grid FSI
{
  Dimension(27,27,27);
  Layer(FSIs, FSIIAFUnit, UniformLayout(1), < nodekind="Nodes" >);
  //Layer(FSIs, FSIIAFUnit, RandomDispersalLayout(19683), < nodekind="Nodes" >);
  InitNodes(.[].Layer(FSIs), heterN);
  connectNodeSets(.[].Layer(FSIs), .[].Layer(FSIs),
                  ipsp_fsi, outAttrDef, ipsp);
  connectNodeSets(.[].Layer(FSIs), .[].Layer(FSIs),
                  gj_fsi, outAttrDef, gj1);
  connectNodeSets(.[].Layer(FSIs), .[].Layer(FSIs),
                  gj_fsi, outAttrDef, gj2);
};

Composite CortexFSI
{
  CTX ctx;
  FSI fsi;
  connectNodeSets(ctx[].Layer(LayerV), fsi[].Layer(FSIs),
                  ctx_2_fsi, outAttrDef, ctxW);
};

CortexFSI iaf;



// ##### Setup data collectors and analyzers #####
<<<<<<< HEAD:graphs/FSI/FSI.gsl
=======
/*
VariableType WaveDriverUnitDataCollector;
WaveDriverUnitDataCollector CTXWcollector<directory=DIRECTORY, fileExt=FILE_EXTENSION,
  op_saveWaves=1>;
polyConnect(iaf/ctx[].Layer(LayerV), CTXWcollector, <>, <>);
*/
>>>>>>> Updated FileDriver output.:graphs/Traub/Traub.gsl
VariableType FileDriverUnitDataCollector;
FileDriverUnitDataCollector CTXFcollector<directory=DIRECTORY, fileExt=FILE_EXTENSION,
  op_saveOutputs=1>;
polyConnect(iaf/ctx[].Layer(LayerV), CTXFcollector, <>, <>);

VariableType FSIIAFUnitDataCollector;
FSIIAFUnitDataCollector FSIcollector<directory=DIRECTORY, fileExt=FILE_EXTENSION,
  op_saveSpikes=1, op_saveSpikesAll=0, Xmin=0, Xmax=8, Ymin=0, Ymax=8, Zmin=0, Zmin=8>;
polyConnect(iaf/fsi[].Layer(FSIs), FSIcollector, <>, <>);

VariableType LFPDataAnalyzer;
LFPDataAnalyzer LFPanalyzer<directory=DIRECTORY, fileExt=FILE_EXTENSION,
  elecRadius=13.27, elecSigma=2.65, numElecPerDimX=4, numElecPerDimY=4, numElecPerDimZ=4,
  op_saveLFPs=1>;
// LFP spacing and size is calculated as below
//        (informed by Einevoll et al, 2013, Nature;
//         Buzsaki et al., 2012, Nature Reviews Neuroscience):
// 1 unit grid = 113 um
// radius 1500 um / 113 um = 13.27 grid units
// sigma 300 um (middle of literature range of 200-400um) / 113 um = 2.65 grid units
polyConnect(iaf/fsi[].Layer(FSIs), LFPanalyzer, <>, <>);



// ##### Setup triggers #####
Trigger UnsignedTrigger(string description, Service svc, string operator,
                        int criterion, int delay);
Trigger CompositeTrigger(string description, Trigger triggerA, int critA,
                         string operator, Trigger triggerB, int critB, int delay);

UnsignedTrigger iterTrig("Iteration Trigger : >= 0 ",
 			 ::Iteration, ">", 0, 0, dataCollect);

UnsignedTrigger iterTrigSampled("Iteration Trigger : !% 50",
                                ::Iteration, "!%", 50, 0, dataCollect);

<<<<<<< HEAD:graphs/FSI/FSI.gsl
UnsignedTrigger endTrig("Iteration Trigger to end or stop",
                        ::Iteration, "==", 1000000, 0, lastPhase); // in dt

UnsignedTrigger setContribTrig("Iteration Trigger to set contribution of indiv neurons at sim init",
                        ::Iteration, "==", 1, 0, setContributions); // in dt

CTXFcollector.dataCollection() on iterTrigSampled;
FSIcollector.dataCollection() on iterTrig;
=======
UnsignedTrigger endTrig("Iteration Trigger to end or stop", 
                        ::Iteration, "==", 100000, 0, lastPhase); // in dt
                     
//CTXWcollector.dataCollection() on iterTrigSampled;                     
CTXFcollector.dataCollection() on iterTrigSampled;
FSIcollector.dataCollectionSpikes() on iterTrig;
FSIcollector.dataCollectionOther() on iterTrigSampled;
>>>>>>> Updated FileDriver output.:graphs/Traub/Traub.gsl
LFPanalyzer.dataCollection() on iterTrigSampled;
LFPanalyzer.setContributions() on setContribTrig;

Stop on endTrig;
