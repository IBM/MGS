#ifndef HodgkinHuxleyVoltage_MDL
#define HodgkinHuxleyVoltage_MDL

#include "../../nti/include/MaxComputeOrder.h"

#include "../std/std.mdl"
#include "../HodgkinHuxley/HodgkinHuxley.mdl"
#include "../BranchSolver/BranchSolver.mdl"
#include "../LaboratoryTools/LaboratoryTools.mdl"

//{{{structs
Struct ChannelCurrents {
//use this for Hodgkin-Huxley equation
  dyn_var_t []* conductances; // [nS/um^2]
  dyn_var_t []* reversalPotentials; // [mV]
}

Struct ChannelCurrentsGHK {
//use this for GHK equation
// which is negative for inward currents
  dyn_var_t []* currents; // [pA/um^2]
#ifdef CONSIDER_DI_DV
  dyn_var_t []* di_dv; // conductance [nS/um^2] - the change from V(t) to V(t+0.001)
#endif
}

Struct ReceptorCurrent {
  dyn_var_t* conductance; // [nS/um^2]
  dyn_var_t* reversalPotential; // [mV]
  int index; //index of the compartment on a given branch to which the current is injected
}

Struct InjectedCurrent {
// which is positive for inward current
  dyn_var_t* current; // (pA)
  dyn_var_t area;  // (um^2) membrane-surface area of the compartment 
  int index;     //  index of the compartment on a given branch to which the current is injected
#ifdef CONSIDER_DI_DV
  dyn_var_t* conductance_didv;  //the di/dv term to help estimate [nS/um^2]
#endif
}
//}}}

//TUAN: TODO consider add SurfaceAreaLengthProducer interface here so that SpineAttachment node 
//          knows about the length and radius of the compartment
// It represents one regular branch (which comprises regular compartments + implicit junctions)
Node HodgkinHuxleyVoltage Implements SolutionArrayProducer, 
     DimensionArrayProducer, BranchDataProducer, 
     ForwardSolutionArrayProducer,
     VoltageArrayProducer, 
#ifdef IDEA_ILEAK
     ConductanceProducer,
     ReversalPotentialProducer,
#endif
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
      CountInformationArrayProducer, 
#endif
     NaConcentrationProducer, KConcentrationProducer 
{
// Regular-branch: represent the diffusion of Voltage along branch with no explicit junction
/*{{{*/
  //DATA
  //{{{
    /*{{{*/
       //data members: reference
       // pointer to array of branch
       // help to identify the branch a Voltage-compartment belong to 
  BranchDataStruct* branchData; // pointer to branch's data
  DimensionStruct* [] dimensions; // 1 branch = N compartments (represented by DimensionStruct)
    //{{{data members: internal, but for solver
  //NOTE: array data of type dyn_var_t become ShallowArray<dyn_var_t> in C++ code
  //NOTE: due to the way nodes/compartment are indexed in NTS (index=0 ~ distal node(child))
  //      so as Aip[] attach to parent-node (it deals with node at index (i+1))
  //      so as Aim[] attach to child-node (it deals with node at index (i-1))
  dyn_var_t [] Aii; //diagonal element of the matrix (A[i,i]) [nS/um^2]
  dyn_var_t [] Aip; //right-side off-diagonal element (parent nodes) [nS/um^2]
  dyn_var_t [] Aim; //left-side off-diagonal element (children-node) [nS/um^2] 
       //... i.e. branch's distalmost compartment to junction coupling coefficient
       //when the node index=0 is the implicit junction compartment; then it does not have
       //a single element Aim[0]; instead it is multiple Aij[]
  dyn_var_t [] Aij; //a term used in place of Aip[0] when the comparment is branching
                    //.. at distal-side
                    //.. i.e. send/receive signals to/from multiple branches

  dyn_var_t [] RHS; //RHS=right-hand side = current-density [pA/um^2]
  dyn_var_t* proximalVoltage; //reference to the voltage from the compartment
                    //.. on a different branch (on proximal side)
  dyn_var_t* [] distalAiis; // get Aii[] from multiple branches
  dyn_var_t* [] distalAips; // get Aip[] from multiple branches
  dyn_var_t* [] distalInputs;// get   Vm from multiple branches
//  dyn_var_t[] * valCur;//pointer to an array (not being used: PLAN to use it the solver)
//  dyn_var_t[] * valNew;
     //keep the pointer to the dimension information (x,y,z,r)
  DimensionStruct* [] distalDimensions; // .. of the first compartment of the adjacent branch(es) 
                                        //    on distal end (it can have many at a branch-point)
  DimensionStruct* proximalDimension;   // .. of the first compartment of the adjacent branch 
                                        //    on proximal end

  bool proximalJunction;// true = the ComputeBranch senses explicit junction at proximal-end
                        //..false=implicit junction
  int computeOrder;// TissueFunctor will assign the value to each branch 
                   // (the range of values from [0..MAX_COMPUTE_ORDER-1])
                   // By choosing MAX_COMPUTE_ORDER>0, we enable the parallel 
                   // computing of branches of the same computeOrder
                   // If MAX_COMPUTE_ORDER=0, then 
                   //  1. solve all branches sequentially 
                   //  from distal to proximal: forwardSolve
                   //  from proximal to distal: backwardSolve
                   //  2. treat all junctions as explicit junction
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  int[] countSpineConnected;
  int[] countGapJunctionConnected;
#endif
       //}}}
  //{{{data members: internal
  dyn_var_t [] Vcur; // [mV]
  dyn_var_t [] Vnew; // [mV]
    // here we may consider the fact that different branches
    // have different gLeak, capacitance Cm, cmt
    // and all compartments on the same branch share the same value
  dyn_var_t Cm; // [pF/um^2]
  dyn_var_t gLeak; // [nS/um^2]
  dyn_var_t cmt; // intermediate values  = 2*Cm/dt [pF/(um^2 . ms)]
   //}}}
#ifdef IDEA_DYNAMIC_INITIALVOLTAGE
  //data mainly used to dynamically assign different conductance on different location
  //NOTE: In SynParams.par file
  //    Use either Vm_dists or Vm_branchorders
  //      and combine with Vm_values
  float [] Vm_dists; // an array that indicate the threshold-distance (in micrometer)
  float [] Vm_branchorders; // an array that indicate the threshold-distance (in micrometer)
  float [] Vm_values;// ... having the corresponding Vm conductance
#endif
    //{{{ ionic currents 
    // IMPORTANT: inward ionic current = negative
    //            inward injectedCurrents is positive
  ChannelCurrents [] channelCurrents; // [pA/um^2]
  ChannelCurrentsGHK [] channelCurrentsGHK; // [pA/um^2]
  ReceptorCurrent [] receptorCurrents; // [pA/um^2]
  InjectedCurrent [] injectedCurrents;  // [pA]
    //}}}
  /*}}}*/
   // design : anything currently not part of the spatial 
   //          is put here
  Shared {
    /*{{{*/
    dyn_var_t* deltaT; // [milisecond] = [ms]
    dyn_var_t Ra; //axial resistance [GOhm.um]
    // intracellular concentrations expressed by ion name alone
    dyn_var_t Na; // [mM] - intracellular
    dyn_var_t K;  // [mM] - intracellular
    dyn_var_t E_leak;  // [miliVolt] = [mV]
    /*}}}*/
  }
  //}}}

  //output
  //{{{
  VoltageArrayProducer.voltageArray << &Vnew;
  SolutionArrayProducer.solutionArray << &Vnew;
  DimensionArrayProducer.dimensionArray << &dimensions;
  BranchDataProducer.branchData << branchData;
  ForwardSolutionArrayProducer.AiiArray << &Aii;
  ForwardSolutionArrayProducer.AipArray << &Aip;
  ForwardSolutionArrayProducer.RHSArray << &RHS;
#ifdef IDEA_ILEAK
  ConductanceProducer.conductance << &gLeak;
  ReversalPotentialProducer.reversalPotential << &Shared.E_leak;
#endif
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  CountInformationArrayProducer.countSpineConnected << &countSpineConnected;
  CountInformationArrayProducer.countGapJunctionConnected << &countGapJunctionConnected;
#endif

  NaConcentrationProducer.Na << &Shared.Na;
  KConcentrationProducer.K << &Shared.K;
  //}}}

#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  UserFunction updateSpineCount, updateGapJunctionCount;
#endif
    // Phases methods
    /*{{{*/
  InitPhase initializeCompartmentData;
  
  #if MAX_COMPUTE_ORDER>0
  RuntimePhase forwardSolve1, backwardSolve1; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve1_corrector, backwardSolve1_corrector; 
#endif
  #endif
  #if MAX_COMPUTE_ORDER>1
  RuntimePhase forwardSolve2, backwardSolve2; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve2_corrector, backwardSolve2_corrector; 
#endif
  #endif
  #if MAX_COMPUTE_ORDER>2
  RuntimePhase forwardSolve3, backwardSolve3; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve3_corrector, backwardSolve3_corrector; 
#endif
  #endif
  #if MAX_COMPUTE_ORDER>3
  RuntimePhase forwardSolve4, backwardSolve4; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve4_corrector, backwardSolve4_corrector; 
#endif
  #endif
  #if MAX_COMPUTE_ORDER>4
  RuntimePhase forwardSolve5, backwardSolve5; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve5_corrector, backwardSolve5_corrector; 
#endif
  #endif
  #if MAX_COMPUTE_ORDER>5
  RuntimePhase forwardSolve6, backwardSolve6; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve6_corrector, backwardSolve6_corrector; 
#endif
  #endif
  #if MAX_COMPUTE_ORDER>6
  RuntimePhase forwardSolve7, backwardSolve7; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve7_corrector, backwardSolve7_corrector; 
#endif
  #endif
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  //RuntimePhase forwardSolve0, backwardSolve0; 
  RuntimePhase forwardSolve0_corrector, backwardSolve0_corrector; 
#endif
  RuntimePhase solve, finish;
    /*}}}*/

  InAttrPSet {
    string identifier;
    TissueSite site;
    int idx;
    float branchProp;
  }
  // d^2 V/dx^2 = dV/dt + Ileak + Iinject + (Isyn+Iion)
  // injectedCurrent  = (to a compartment) only if 2 scenarios
  //               1. it forms an bi-directional
  //                      connection (e.g. electrical-synapse or spine-neck)
  //               2. a stimulus current is injected
  UserFunction setReceptorCurrent, setInjectedCurrent, setProximalJunction;
#ifdef CONSIDER_DI_DV
  UserFunction add_zero_didv;
#endif
  // Connection setup (i.e. input)
  //{{{ 
  Connection Pre Constant (PSet.identifier=="dimension") Expects DimensionProducer {
    DimensionProducer.dimension >> dimensions;
   }

  Connection Pre Constant (PSet.identifier=="branchData") Expects BranchDataProducer {
    BranchDataProducer.branchData >> branchData;
   }

  //Use for HH-based any current formula
  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects ConductanceArrayProducer, 
    ReversalPotentialArrayProducer {
    ConductanceArrayProducer.conductanceArray >> channelCurrents.conductances;
    ReversalPotentialArrayProducer.reversalPotentials >> channelCurrents.reversalPotentials;
  }

  //Use for GHK-based any current formula
  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects CurrentArrayProducer
  {
    CurrentArrayProducer.currents >> channelCurrentsGHK.currents;
#ifdef CONSIDER_DI_DV
    CurrentArrayProducer.di_dv >> channelCurrentsGHK.di_dv;
#endif
  }
 
//TODO: MAYBE we need to convert gapjunction current from Iinject(pA) 
//          Iinject_to_sideB = g*(VsideA-VsideB)
//  into 
//   I_to_sideA=g*(VsideA - VsideB)
  Connection Pre Node (PSet.identifier=="electricalSynapse[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents.current;
    setInjectedCurrent();
#ifdef CONSIDER_DI_DV
    //must call after setInjectedCurrent();
    add_zero_didv();
#endif
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    updateGapJunctionCount();
#endif
   }

#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2
  Connection Pre Node (PSet.identifier=="spineAttachment[Voltage]") Expects ConductanceProducer, ReversalPotentialProducer {
    ConductanceProducer.conductance >> receptorCurrents.conductance;
    ReversalPotentialProducer.reversalPotential >> receptorCurrents.reversalPotential;
    setReceptorCurrent();
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    updateSpineCount();
#endif
   }
#else
//NOTE: We probably won't be using this option for good
  Connection Pre Node (PSet.identifier=="spineAttachment[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents.current;
    setInjectedCurrent();
#ifdef CONSIDER_DI_DV
    //must call after setInjectedCurrent();
    add_zero_didv();
#endif
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
    updateSpineCount();
#endif
   }
#endif
  Connection Pre Node (PSet.identifier=="chemicalSynapse[Voltage]") Expects 
    ConductanceProducer, ReversalPotentialProducer 
  {
    ConductanceProducer.conductance >> receptorCurrents.conductance;
    ReversalPotentialProducer.reversalPotential >> receptorCurrents.reversalPotential;
    setReceptorCurrent();
   }

  PredicateFunction checkSite;
  Connection Pre Variable (PSet.identifier=="VClamp" && checkSite()) Expects 
      CurrentProducer 
#ifdef CONSIDER_DI_DV
    , DIDV_ConductanceProducer
#endif
   {
    CurrentProducer.current >> injectedCurrents.current;
#ifdef CONSIDER_DI_DV
    DIDV_ConductanceProducer.conductance_didv >> injectedCurrents.conductance_didv;
#endif
    setInjectedCurrent();
   }

  Connection Pre Variable (PSet.identifier=="stimulation" && checkSite()) Expects 
    CurrentProducer
   {
    CurrentProducer.current >> injectedCurrents.current;
    setInjectedCurrent();
#ifdef CONSIDER_DI_DV
    //must call after setInjectedCurrent();
    add_zero_didv();
#endif
   }

  Connection Pre Node (PSet.identifier=="proximalJunctionPoint") Expects VoltageProducer, DimensionProducer {
    VoltageProducer.voltage >> proximalVoltage;
    DimensionProducer.dimension >> proximalDimension;
    setProximalJunction();
  }

  Connection Pre Node (PSet.identifier=="distalJunctionPoint") Expects VoltageProducer, DimensionProducer {
    VoltageProducer.voltage >> distalInputs;
    DimensionProducer.dimension >> distalDimensions;
  }

  Connection Pre Node (PSet.identifier=="backwardSolvePoint") Expects SolutionProducer, DimensionProducer {
    SolutionProducer.solution >> proximalVoltage;
    DimensionProducer.dimension >> proximalDimension;
  }

  Connection Pre Node (PSet.identifier=="forwardSolvePoint") Expects ForwardSolutionProducer, DimensionProducer {
    ForwardSolutionProducer.Aii >> distalAiis;
    ForwardSolutionProducer.Aip >> distalAips;
    ForwardSolutionProducer.RHS >> distalInputs;
    DimensionProducer.dimension >> distalDimensions;
  }

  PredicateFunction confirmUniqueDeltaT;
  Connection Pre Constant (PSet.identifier=="dt" && confirmUniqueDeltaT()) Expects TimeStepProducer {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
  //}}}
/*}}}*/
}


// represent an end-point (i.e. last compartment in the series of compartments along a branch 
//                         that face explicit junction)
// thus don't hold real data, just a reference to that last segment
Node VoltageEndPoint Implements VoltageProducer, DimensionProducer, BranchDataProducer
{
// For each regular-branch represented by HodgkinHuxleyVoltage
// that has computeOrder=0 or computeOrder=MAX_COMPUTE_ORDER-1, 
// if computeOrder=0: 
//         it has an associated EndPoint instance references to 'proximalEnd'
// if computeOrder=MAX_COMPUTER_ORDER-1: 
//         it has an associated EndPoints instance references to 'distalEnd' 
/*{{{*/
  dyn_var_t* voltage; // reference to the voltage of the compartment at either 'distalEnd' or 'proximalEnd'
  DimensionStruct* dimension; //reference to the struct representing the compartment
  BranchDataStruct* branchData; // pointer to branch's data

  Shared {
    // so the two instances share the Branch's data
    // an array but indeed is a scalar
    dyn_var_t []* voltageConnect; 
    DimensionStruct* []* dimensionsConnect;
  }

  //output
  VoltageProducer.voltage << voltage;
  DimensionProducer.dimension << dimension;
  BranchDataProducer.branchData << branchData;

  InAttrPSet {//attribute of the incoming MDL component, e.g. node
    string identifier; //either 'distalEnd' or 'proximalEnd'
  }

  UserFunction setPointers; // which is called to create the proper memory reference for 'voltage' of the end-point component
            // can be 'distalEnd' or 'proximalEnd' depending upon the incoming node's InAttrPset's identifier's value

  //input
  Connection Pre Node () Expects VoltageArrayProducer, DimensionArrayProducer, BranchDataProducer {
    VoltageArrayProducer.voltageArray >> Shared.voltageConnect;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    BranchDataProducer.branchData >> branchData;
    setPointers();
  }
  // as end-point, so we use 'produce' prefix for kernels
  InitPhase produceInitialState(dimension);
  RuntimePhase produceSolvedVoltage(voltage);
  RuntimePhase produceFinishedVoltage(voltage);
/*}}}*/
}

// It represents one explicit junction branch (which comprise half regular compartments)
Node HodgkinHuxleyVoltageJunction Implements DimensionArrayProducer, BranchDataProducer,
     VoltageArrayProducer, 
#ifdef IDEA_ILEAK
     ConductanceProducer,
     ReversalPotentialProducer,
#endif
#ifdef RECORD_AXIAL_CURRENT_AS_INJECTED_CURRENT
     IOCurrentProducer,
#endif
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
      CountInformationArrayProducer, 
#endif
   NaConcentrationProducer, KConcentrationProducer 
{
// Explicit junction branch: a single-compartment branch which represents either
//        1. the soma
//        2. a branching node between two compute_branch of compute-order MAX_COMPUTE_ORDER and 0 
//   CASE 1: geometry is simply the whole-soma spherical capsule
//   CASE 2: geometry is created by taking half-compartments (or better half-capsules) 
//           (from the parent compartment, and all others are from
//            daughter branches) 
// The diffusion between this compartment (of junction branch) 
//   and adjacent compartments (each from either parent-compute-branch or any of 
//       the children compute-branches)
//   is modeled as 'gAxial' and cross-sectional area 'area'
/*{{{*/
  //DATA
  //{{{
  BranchDataStruct* branchData;  // the proximal-side regular-branch's data
  DimensionStruct* [] dimensions; //the proximal-side regular-branch's compartments
    //{{{data members: internal, but for solver
  dyn_var_t* [] voltageInputs; //voltage from different compartments in the junction-branch
  DimensionStruct* [] dimensionInputs; //points from different compartments on different branches
  BranchDataStruct* [] branchDataInputs;  // 
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  int []countSpineConnected;
  int []countGapJunctionConnected;
#endif
    //}}}
  //{{{data members: internal
  dyn_var_t area;//surface area [um^2]
  dyn_var_t [] gAxial; //axial-conductance  [GOm.um]
  dyn_var_t Vcur; // iso-potential for all compartments in junction-branch [mV]
  dyn_var_t [] Vnew; // indeed only one element,  [mV]

  dyn_var_t Cm; // [pF/um^2]
  dyn_var_t cmt; // intermediate value = 2*Cm/dt [pF/(um^2 . ms)]
  dyn_var_t gLeak; // [nS/um^2]
#ifdef RECORD_AXIAL_CURRENT_AS_INJECTED_CURRENT
  dyn_var_t I_fromdend; // [pA]
#endif
  //}}}
#ifdef IDEA_DYNAMIC_INITIALVOLTAGE
  //data mainly used to dynamically assign different conductance on different location
  //NOTE: In SynParams.par file
  //    Use either Vm_dists or Vm_branchorders
  //      and combine with Vm_values
  float [] Vm_dists; // an array that indicate the threshold-distance (in micrometer)
  float [] Vm_branchorders; // an array that indicate the threshold-distance (in micrometer)
  float [] Vm_values;// ... having the corresponding Vm conductance
#endif
  //{{{ ionic currents
  ChannelCurrents [] channelCurrents;
  ChannelCurrentsGHK [] channelCurrentsGHK;
  dyn_var_t* [] receptorConductances;
  dyn_var_t* [] receptorReversalPotentials;
  dyn_var_t* [] injectedCurrents;
#ifdef CONSIDER_DI_DV
  dyn_var_t* [] injectedCurrents_conductance_didv;
#endif
  //}}}


  Shared {
    //{{{
    dyn_var_t* deltaT; // [milisecond] = [ms]
    dyn_var_t Ra; //axial resistance [GOhm.um]
    // intracellular concentrations expressed by ion name alone
    dyn_var_t Na; // [mM]
    dyn_var_t K;  // [mM]
    dyn_var_t E_leak;  // [miliVolt] = [mV]
    //}}}
  }
  //}}}

  //output
  VoltageArrayProducer.voltageArray << &Vnew;
  DimensionArrayProducer.dimensionArray << &dimensions;
  BranchDataProducer.branchData << branchData;
#ifdef IDEA_ILEAK
  ConductanceProducer.conductance << &gLeak;
  ReversalPotentialProducer.reversalPotential << &Shared.E_leak;
#endif
#ifdef RECORD_AXIAL_CURRENT_AS_INJECTED_CURRENT
  IOCurrentProducer.current << &I_fromdend;
#endif
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  CountInformationArrayProducer.countSpineConnected << &countSpineConnected;
  CountInformationArrayProducer.countGapJunctionConnected << &countGapJunctionConnected;
#endif

  NaConcentrationProducer.Na << &Shared.Na;
  KConcentrationProducer.K << &Shared.K;

   //{{{ Phases 
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  UserFunction updateSpineCount, updateGapJunctionCount;
#endif
#ifdef CONSIDER_DI_DV
  UserFunction add_zero_didv;
#endif
  InitPhase initializeJunction;
   
  RuntimePhase predictJunction, correctJunction;
   // }}}

  InAttrPSet {
    string identifier;
    TissueSite site;
    int idx;
  }  

  //input
  // the junction-branch connects to regular-branch through the regular-branch's endpoints
  Connection Pre Node (PSet.identifier=="endpoint") Expects VoltageProducer, 
    DimensionProducer, BranchDataProducer  {
    VoltageProducer.voltage >> voltageInputs;
    DimensionProducer.dimension >> dimensionInputs;
    BranchDataProducer.branchData >> branchDataInputs;
  }

  Connection Pre Constant (PSet.identifier=="dimension") Expects DimensionProducer {
    DimensionProducer.dimension >> dimensions;
   }

  Connection Pre Constant (PSet.identifier=="branchData") Expects BranchDataProducer {
    BranchDataProducer.branchData >> branchData;
   }

  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects ConductanceArrayProducer, 
    ReversalPotentialArrayProducer {
    ConductanceArrayProducer.conductanceArray >> channelCurrents.conductances;
    ReversalPotentialArrayProducer.reversalPotentials >> channelCurrents.reversalPotentials;
   }

  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects CurrentArrayProducer
  {
    CurrentArrayProducer.currents >> channelCurrentsGHK.currents;
#ifdef CONSIDER_DI_DV
    CurrentArrayProducer.di_dv >> channelCurrentsGHK.di_dv;
#endif
  }

  Connection Pre Node (PSet.identifier=="electricalSynapse[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents;
#ifdef CONSIDER_DI_DV
    add_zero_didv();
#endif
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    updateGapJunctionCount();
#endif
   }

#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2
  Connection Pre Node (PSet.identifier=="spineAttachment[Voltage]") Expects ConductanceProducer, ReversalPotentialProducer {
    ConductanceProducer.conductance >> receptorConductances;
    ReversalPotentialProducer.reversalPotential >> receptorReversalPotentials;
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    updateSpineCount();
#endif
   }
#else
//NOTE: We probably won't be using this option for good
  Connection Pre Node (PSet.identifier=="spineAttachment[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents;
#ifdef CONSIDER_DI_DV
    add_zero_didv();
#endif
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
    updateSpineCount();
#endif
   }
#endif

  Connection Pre Node (PSet.identifier=="chemicalSynapse[Voltage]") Expects ConductanceProducer, 
    ReversalPotentialProducer {
    ConductanceProducer.conductance >> receptorConductances;
    ReversalPotentialProducer.reversalPotential >> receptorReversalPotentials;
   }

  PredicateFunction checkSite;
  Connection Pre Variable (PSet.identifier=="VClamp" && checkSite()) Expects 
    CurrentProducer
#ifdef CONSIDER_DI_DV
    , DIDV_ConductanceProducer
#endif
   {
    CurrentProducer.current >> injectedCurrents;
#ifdef CONSIDER_DI_DV
    DIDV_ConductanceProducer.conductance_didv >> injectedCurrents_conductance_didv;
#endif
   }

  Connection Pre Variable (PSet.identifier=="stimulation" && checkSite()) Expects 
    CurrentProducer
   {// current-clamp
    CurrentProducer.current >> injectedCurrents;
#ifdef CONSIDER_DI_DV
    add_zero_didv();
#endif
   }

  PredicateFunction confirmUniqueDeltaT;
  Connection Pre Constant (PSet.identifier=="dt" && confirmUniqueDeltaT()) Expects TimeStepProducer {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
/*}}}*/
}

Node VoltageJunctionPoint Implements VoltageProducer, DimensionProducer
{
// For each junction-branch, represented by HodgkinHuxleyVoltageJunction
// we need 1 associated JunctionPoints that reference to the end...
/*{{{*/
  dyn_var_t* voltage;
  DimensionStruct* dimension;

  Shared {
    dyn_var_t []* voltageConnect;
    DimensionStruct* []* dimensionsConnect;
  }
  VoltageProducer.voltage << voltage;
  DimensionProducer.dimension << dimension;

  InAttrPSet {
    string identifier;
  }

  UserFunction setPointers;

  Connection Pre Node () Expects VoltageArrayProducer, DimensionArrayProducer {
    VoltageArrayProducer.voltageArray >> Shared.voltageConnect;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    setPointers();
  }
  InitPhase produceInitialState(dimension);
  RuntimePhase produceVoltage(voltage);
/*}}}*/
}

#endif
