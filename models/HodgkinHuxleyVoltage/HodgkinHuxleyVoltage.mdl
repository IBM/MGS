#ifndef HodgkinHuxleyVoltage_MDL
#define HodgkinHuxleyVoltage_MDL

#include "../../nti/include/MaxComputeOrder.h"

#include "../std/std.mdl"
#include "../HodgkinHuxley/HodgkinHuxley.mdl"
#include "../BranchSolver/BranchSolver.mdl"
#include "../LaboratoryTools/LaboratoryTools.mdl"

Struct ChannelCurrents {
//use this for Hodgkin-Huxley equation
  dyn_var_t []* conductances; // [nS/um^2]
  dyn_var_t []* reversalPotentials; // [mV]
}

Struct ChannelCurrentsGHK {
//use this for GHK equation
// which is negative for inward currents
  dyn_var_t []* currents; // [pA/um^2]
}

Struct ReceptorCurrent {
  dyn_var_t* conductance; // [nS/um^2]
  dyn_var_t* reversalPotential; // [mV]
  int index; //index of the compartment on a given branch to which the current is injected
}

Struct InjectedCurrent {
// which is positive for inward current
  dyn_var_t* current; // (pA)
  dyn_var_t area;  // (um^2) membrane-surface area of the compartment 
  int index;     //  index of the compartment on a given branch to which the current is injected
}

//TUAN: TODO consider add SurfaceAreaLengthProducer interface here so that SpineAttachment node 
//          knows about the length and radius of the compartment
// It represents one regular branch (which comprises regular compartments + implicit junctions)
Node HodgkinHuxleyVoltage Implements SolutionArrayProducer, 
     DimensionArrayProducer, BranchDataProducer, 
     ForwardSolutionArrayProducer,
     VoltageArrayProducer, 
     NaConcentrationProducer, KConcentrationProducer 
{
// Regular-branch: represent the diffusion of Voltage along branch with no explicit junction
/*{{{*/
	//DATA
    /*{{{*/
	//data members: reference
       // pointer to array of branch
       // help to identify the branch a Voltage-compartment belong to 
  BranchDataStruct* branchData; // pointer to branch's data
  DimensionStruct* [] dimensions; // 1 branch = N compartments (represented by DimensionStruct)
	//data members: internal, but for solver
    //{{{
	//NOTE: array data become ShallowArray<dyn_var_t> Aii in C++ code
  dyn_var_t [] Aii; //diagonal element of the matrix (A[i,i]) [nS/um^2]
  dyn_var_t [] Aip; //right-side off-diagonal element         [nS/um^2]
  dyn_var_t [] Aim; //left-side off-diagonal element          [nS/um^2] 
       //... i.e. branch's distalmost compartment to junction coupling coefficient

  dyn_var_t [] RHS; //RHS=right-hand side = current-density [pA/um^2]
  dyn_var_t [] Aij; //a term as part of Aii[] when the comparment is branching
                    //.. at distal-side
                    //.. i.e. send/receive signals to/from multiple branches
  dyn_var_t* proximalVoltage; //reference to the voltage from the compartment
                    //.. on a different branch (on proximal side)
  dyn_var_t* [] distalAiis; // get Aii[] from multiple branches
  dyn_var_t* [] distalAips; // get Aip[] from multiple branches
  dyn_var_t* [] distalInputs;// get   Vm from multiple branches
//  dyn_var_t[] * valCur;//pointer to an array (not being used: PLAN to use it the solver)
//  dyn_var_t[] * valNew;
     //keep the pointer to the dimension information (x,y,z,r)
  DimensionStruct* [] distalDimensions; // .. of the first compartment of the adjacent branch(es) 
                                        //    on distal end (it can have many at a branch-point)
  DimensionStruct* proximalDimension;   // .. of the first compartment of the adjacent branch 
                                        //    on proximal end

  bool proximalJunction;// true = the ComputeBranch senses explicit junction at proximal-end
                        //..false=implicit junction
  int computeOrder;// TissueFunctor will assign the value to each branch 
                   // (the range of values from [0..MAX_COMPUTE_ORDER-1])
                   // By choosing MAX_COMPUTE_ORDER>0, we enable the parallel 
                   // computing of branches of the same computeOrder
                   // If MAX_COMPUTE_ORDER=0, then 
                   //  1. solve all branches sequentially 
                   //  from distal to proximal: forwardSolve
                   //  from proximal to distal: backwardSolve
                   //  2. treat all junctions as explicit junction
       //}}}
	//data members: internal
  dyn_var_t [] Vcur; // [mV]
  dyn_var_t [] Vnew; // [mV]
    // here we may consider the fact that different branches
    // have different gLeak, capacitance Cm, cmt
    // and all compartments on the same branch share the same value
  dyn_var_t Cm; // [pF/um^2]
  dyn_var_t gLeak; // [nS/um^2]
  dyn_var_t cmt; // intermediate values  = 2*Cm/dt [pF/(um^2 . ms)]
    // currents 
    // IMPORTANT: inward ionic current = negative
    //            inward injectedCurrents is positive
  ChannelCurrents [] channelCurrents; // [pA/um^2]
  ChannelCurrentsGHK [] channelCurrentsGHK; // [pA/um^2]
  ReceptorCurrent [] receptorCurrents; // [pA/um^2]
  InjectedCurrent [] injectedCurrents;  // [pA]
	/*}}}*/
   // design : anything currently not part of the spatial 
   //          is put here
  Shared {
    /*{{{*/
    dyn_var_t* deltaT; // [milisecond] = [ms]
    dyn_var_t Ra; //axial resistance [GOhm.um]
    // intracellular concentrations expressed by ion name alone
    dyn_var_t Na; // [mM]
    dyn_var_t K;  // [mM]
    dyn_var_t E_leak;  // [miliVolt] = [mV]
    /*}}}*/
  }

	//output
	//{{{
  VoltageArrayProducer.voltageArray << &Vnew;
  SolutionArrayProducer.solutionArray << &Vnew;
  DimensionArrayProducer.dimensionArray << &dimensions;
  BranchDataProducer.branchData << branchData;
  ForwardSolutionArrayProducer.AiiArray << &Aii;
  ForwardSolutionArrayProducer.AipArray << &Aip;
  ForwardSolutionArrayProducer.RHSArray << &RHS;

  NaConcentrationProducer.Na << &Shared.Na;
  KConcentrationProducer.K << &Shared.K;
	//}}}

    // Phases methods
    /*{{{*/
  InitPhase initializeCompartmentData;
  
  #if MAX_COMPUTE_ORDER>0
  RuntimePhase forwardSolve1, backwardSolve1; 
  #endif
  #if MAX_COMPUTE_ORDER>1
  RuntimePhase forwardSolve2, backwardSolve2; 
  #endif
  #if MAX_COMPUTE_ORDER>2
  RuntimePhase forwardSolve3, backwardSolve3; 
  #endif
  #if MAX_COMPUTE_ORDER>3
  RuntimePhase forwardSolve4, backwardSolve4; 
  #endif
  #if MAX_COMPUTE_ORDER>4
  RuntimePhase forwardSolve5, backwardSolve5; 
  #endif
  #if MAX_COMPUTE_ORDER>5
  RuntimePhase forwardSolve6, backwardSolve6; 
  #endif
  #if MAX_COMPUTE_ORDER>6
  RuntimePhase forwardSolve7, backwardSolve7; 
  #endif
  RuntimePhase solve, finish;
    /*}}}*/

  InAttrPSet {
    string identifier;
    TissueSite site;
    int idx;
  }
  // d^2 V/dx^2 = dV/dt + Ileak + Iinject + (Isyn+Iion)
  // injectedCurrent  = (to a compartment) only if 2 scenarios
  //               1. it forms an bi-directional
  //                      connection (e.g. electrical-synapse or spine-neck)
  //               2. a stimulus current is injected
  UserFunction setReceptorCurrent, setInjectedCurrent, setProximalJunction;
  // Connection setup (i.e. input)
  //{{{ 
  Connection Pre Constant (PSet.identifier=="dimension") Expects DimensionProducer {
    DimensionProducer.dimension >> dimensions;
   }

  Connection Pre Constant (PSet.identifier=="branchData") Expects BranchDataProducer {
    BranchDataProducer.branchData >> branchData;
   }

  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects ConductanceArrayProducer, ReversalPotentialArrayProducer {
    ConductanceArrayProducer.conductanceArray >> channelCurrents.conductances;
    ReversalPotentialArrayProducer.reversalPotentials >> channelCurrents.reversalPotentials;
  }

  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects CurrentArrayProducer
  {
    CurrentArrayProducer.currents >> channelCurrentsGHK.currents;
  }

  Connection Pre Node (PSet.identifier=="electricalSynapse[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents.current;
    setInjectedCurrent();
   }

  Connection Pre Node (PSet.identifier=="spineAttachment[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents.current;
    setInjectedCurrent();
   }
  Connection Pre Node (PSet.identifier=="chemicalSynapse[Voltage]") Expects ConductanceProducer, ReversalPotentialProducer {
    ConductanceProducer.conductance >> receptorCurrents.conductance;
    ReversalPotentialProducer.reversalPotential >> receptorCurrents.reversalPotential;
    setReceptorCurrent();
   }

  PredicateFunction checkSite;
  Connection Pre Variable (PSet.identifier=="stimulation" && checkSite()) Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents.current;
    setInjectedCurrent();
   }

  Connection Pre Node (PSet.identifier=="proximalJunctionPoint") Expects VoltageProducer, DimensionProducer {
    VoltageProducer.voltage >> proximalVoltage;
    DimensionProducer.dimension >> proximalDimension;
    setProximalJunction();
  }

  Connection Pre Node (PSet.identifier=="distalJunctionPoint") Expects VoltageProducer, DimensionProducer {
    VoltageProducer.voltage >> distalInputs;
    DimensionProducer.dimension >> distalDimensions;
  }

  Connection Pre Node (PSet.identifier=="backwardSolvePoint") Expects SolutionProducer, DimensionProducer {
    SolutionProducer.solution >> proximalVoltage;
    DimensionProducer.dimension >> proximalDimension;
  }

  Connection Pre Node (PSet.identifier=="forwardSolvePoint") Expects ForwardSolutionProducer, DimensionProducer {
    ForwardSolutionProducer.Aii >> distalAiis;
    ForwardSolutionProducer.Aip >> distalAips;
    ForwardSolutionProducer.RHS >> distalInputs;
    DimensionProducer.dimension >> distalDimensions;
  }

  PredicateFunction confirmUniqueDeltaT;
  Connection Pre Constant (PSet.identifier=="dt" && confirmUniqueDeltaT()) Expects TimeStepProducer {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
  //}}}
/*}}}*/
}


// represent an end-point (i.e. last compartment in the series of compartments along a branch 
//                         that face explicit junction)
// thus don't hold real data, just a reference to that last segment
Node VoltageEndPoint Implements VoltageProducer, DimensionProducer
{
// For each regular-branch represented by HodgkinHuxleyVoltage
// that has computeOrder=0 or computeOrder=MAX_COMPUTE_ORDER-1, 
// if computeOrder=0: 
//         it has an associated EndPoint instance references to 'proximalEnd'
// if computeOrder=MAX_COMPUTER_ORDER-1: 
//         it has an associated EndPoints instance references to 'distalEnd' 
/*{{{*/
  dyn_var_t* voltage; // reference to the voltage of the compartment at either 'distalEnd' or 'proximalEnd'
  DimensionStruct* dimension; //reference to the struct representing the compartment

  Shared {
    // so the two instances share the Branch's data
		// an array but indeed is a scalar
    dyn_var_t []* voltageConnect; 
    DimensionStruct* []* dimensionsConnect;
  }

  //output
  VoltageProducer.voltage << voltage;
  DimensionProducer.dimension << dimension;

  InAttrPSet {//attribute of the incoming MDL component, e.g. node
    string identifier; //either 'distalEnd' or 'proximalEnd'
  }

  UserFunction setPointers; // which is called to create the proper memory reference for 'voltage' of the end-point component
            // can be 'distalEnd' or 'proximalEnd' depending upon the incoming node's InAttrPset's identifier's value

  //input
  Connection Pre Node () Expects VoltageArrayProducer, DimensionArrayProducer {
    VoltageArrayProducer.voltageArray >> Shared.voltageConnect;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    setPointers();
  }
	// as end-point, so we use 'produce' prefix for kernels
  InitPhase produceInitialState(dimension);
  RuntimePhase produceSolvedVoltage(voltage);
  RuntimePhase produceFinishedVoltage(voltage);
/*}}}*/
}

// It represents one explicit junction branch (which comprise half regular compartments)
Node HodgkinHuxleyVoltageJunction Implements DimensionArrayProducer, BranchDataProducer,
     VoltageArrayProducer, 
	 NaConcentrationProducer, KConcentrationProducer 
{
// Explicit junction branch: a branch comprised of half-compartments (or better half-capsules) 
//   at a junction 
//   All half-compartments (one from the parent compartment, and all others are from
//          daughter branches) are assumed iso-potential (i.e. same Vm)
// The diffusion between the half-compartments in junction-branch 
//   is modeled as 'gAxial' and 
//       cross-sectional area 'area'
// NOTE: A soma is a special kind of junction-branch
//   and its surface are is treated differently
/*{{{*/
  BranchDataStruct* branchData;  // the proximal-side regular-branch's data
  DimensionStruct* [] dimensions; //the proximal-side regular-branch's compartments
  dyn_var_t area;//surface area [um^2]
  dyn_var_t [] gAxial; //axial-conductance  [GOm.um]
  dyn_var_t Vcur; // iso-potential for all compartments in junction-branch [mV]
  dyn_var_t [] Vnew; // indeed only one element,  [mV]

  dyn_var_t Cm; // [pF/um^2]
  dyn_var_t cmt; // intermediate value = 2*Cm/dt [pF/(um^2 . ms)]
  dyn_var_t gLeak; // [nS/um^2]

  // currents
  ChannelCurrents [] channelCurrents;
  ChannelCurrentsGHK [] channelCurrentsGHK;
  dyn_var_t* [] receptorConductances;
  dyn_var_t* [] receptorReversalPotentials;
  dyn_var_t* [] injectedCurrents;

  dyn_var_t* [] voltageInputs; //voltage from different compartments in the junction-branch
  DimensionStruct* [] dimensionInputs; //points from different compartments on different branches

  Shared {
	  //{{{
    dyn_var_t* deltaT; // [milisecond] = [ms]
    dyn_var_t Ra; //axial resistance [GOhm.um]
    // intracellular concentrations expressed by ion name alone
    dyn_var_t Na; // [mM]
    dyn_var_t K;  // [mM]
    dyn_var_t E_leak;  // [miliVolt] = [mV]
      //}}}
  }

  //output
  VoltageArrayProducer.voltageArray << &Vnew;
  DimensionArrayProducer.dimensionArray << &dimensions;
  BranchDataProducer.branchData << branchData;

  NaConcentrationProducer.Na << &Shared.Na;
  KConcentrationProducer.K << &Shared.K;

  InitPhase initializeJunction;
   
  RuntimePhase predictJunction, correctJunction;

  InAttrPSet {
    string identifier;
    TissueSite site;
    int idx;
  }	

  //input
  // the junction-branch connects to regular-branch through the regular-branch's endpoints
  Connection Pre Node (PSet.identifier=="endpoint") Expects VoltageProducer, DimensionProducer  {
    VoltageProducer.voltage >> voltageInputs;
    DimensionProducer.dimension >> dimensionInputs;
  }

  Connection Pre Constant (PSet.identifier=="dimension") Expects DimensionProducer {
    DimensionProducer.dimension >> dimensions;
   }

  Connection Pre Constant (PSet.identifier=="branchData") Expects BranchDataProducer {
    BranchDataProducer.branchData >> branchData;
   }

  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects ConductanceArrayProducer, 
    ReversalPotentialArrayProducer {
    ConductanceArrayProducer.conductanceArray >> channelCurrents.conductances;
    ReversalPotentialArrayProducer.reversalPotentials >> channelCurrents.reversalPotentials;
   }

  Connection Pre Node (PSet.identifier=="channels[Voltage]") Expects CurrentArrayProducer
  {
    CurrentArrayProducer.currents >> channelCurrentsGHK.currents;
  }

  Connection Pre Node (PSet.identifier=="electricalSynapse[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents;
   }

  Connection Pre Node (PSet.identifier=="spineAttachment[Voltage]") Expects CurrentProducer {
    CurrentProducer.current >> injectedCurrents;
   }

  Connection Pre Node (PSet.identifier=="chemicalSynapse[Voltage]") Expects ConductanceProducer, 
    ReversalPotentialProducer {
    ConductanceProducer.conductance >> receptorConductances;
    ReversalPotentialProducer.reversalPotential >> receptorReversalPotentials;
   }

  PredicateFunction checkSite;
  Connection Pre Variable (PSet.identifier=="stimulation" && checkSite()) Expects 
    CurrentProducer {
    CurrentProducer.current >> injectedCurrents;
   }

  PredicateFunction confirmUniqueDeltaT;
  Connection Pre Constant (PSet.identifier=="dt" && confirmUniqueDeltaT()) Expects TimeStepProducer {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
/*}}}*/
}

Node VoltageJunctionPoint Implements VoltageProducer, DimensionProducer
{
// For each junction-branch, represented by HodgkinHuxleyVoltageJunction
// we need 1 associated JunctionPoints that reference to the end...
/*{{{*/
  dyn_var_t* voltage;
  DimensionStruct* dimension;

  Shared {
    dyn_var_t []* voltageConnect;
    DimensionStruct* []* dimensionsConnect;
  }
  VoltageProducer.voltage << voltage;
  DimensionProducer.dimension << dimension;

  InAttrPSet {
    string identifier;
  }

  UserFunction setPointers;

  Connection Pre Node () Expects VoltageArrayProducer, DimensionArrayProducer {
    VoltageArrayProducer.voltageArray >> Shared.voltageConnect;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    setPointers();
  }
  InitPhase produceInitialState(dimension);
  RuntimePhase produceVoltage(voltage);
/*}}}*/
}

#endif
