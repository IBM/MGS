#ifndef CaConcentration_MDL
#define CaConcentration_MDL

#include "../../nti/include/MaxComputeOrder.h"
#include "../std/std.mdl"
#include "../HodgkinHuxley/HodgkinHuxley.mdl"
#include "../BranchSolver/BranchSolver.mdl"
#include "../LaboratoryTools/LaboratoryTools.mdl"


//NOTE: We had CaClearance [1/ms] to model the removal of Ca2+ back to the basal level CaBaseline
//      This is replaced by CaRemoval mechanism or PMCA pump with tau [ms]

// It represents one branch (which comprises regular compartments + implicit junctions)
Node CaConcentration Implements SolutionArrayProducer, 
     DimensionArrayProducer, BranchDataProducer,
     ForwardSolutionArrayProducer, 
     CaConcentrationArrayProducer
#ifdef MICRODOMAIN_CALCIUM
     , CaMicrodomainConcentrationArrayProducer
     , CaMicrodomainNameArrayProducer
#endif
{
// Regular-branch: represent the diffusion of Calcium(cyto) along branch with no explicit junction
/*{{{*/
  //DATA
  /*{{{*/
  //data members: reference
  // pointer to array of branch
  // help to identify the branch a Calcium(cyto)-compartment belong to 
  BranchDataStruct* branchData; // pointer to branchs data
  DimensionStruct* [] dimensions; // each branch has many compartments (whose center point represented by DimensionStruct)
  //data members: internal, but for solver
  //{{{
  //NOTE: array data become ShallowArray<dyn_var_t> Aii in C++ code
  dyn_var_t [] Aii; // TODO unit
  dyn_var_t [] Aip; // TODO unit
  dyn_var_t [] Aim; // branchs distalmost compartment to junction coupling coefficient

  dyn_var_t [] RHS; // [uM/ms]
  dyn_var_t [] Aij; // TODO unit

  //dyn_var_t  CaClearance; // [1/ms]

  dyn_var_t* proximalCaConcentration; // TODO unit
  dyn_var_t* [] distalAiis;
  dyn_var_t* [] distalAips;
  dyn_var_t* [] distalInputs;
  //dyn_var_t[] * valCur;//pointer to an array
  //dyn_var_t[] * valNew;
  DimensionStruct* [] distalDimensions;
  DimensionStruct* proximalDimension;

  bool proximalJunction;// true = real-branching point, 
  //..false=implicit-cut (i.e. cut along the branch)
  int computeOrder;// TissueFunctor will assign the value to each branch 
  // (the range of values from [0..MAX_COMPUTE_ORDER-1])
  // By choosing MAX_COMPUTE_ORDER>0, we enable the parallel 
  // computing of branches of the same computeOrder
  // If MAX_COMPUTE_ORDER=0, then 
  // solve all branches sequentially 
  //  from distal to proximal: forwardSolve
  //  from proximal to distal: backwardSolve
  //}}}
  //data members: internal
  dyn_var_t [] Ca_cur; // intracellular concentrations expressed by ion name alone
  dyn_var_t [] Ca_new;
  dyn_var_t [] currentDensityToConc;
#ifdef  USE_CALCIUM_INDICATOR
  dyn_var_t [] Fluo;  //[uM]
  dyn_var_t [] FluoCa;// Ca2+-bound [uM]
#endif

  //{{{microdomain
#ifdef MICRODOMAIN_CALCIUM
  //NOTE: first [] = number of compartments per compute-branch
  //     second [] = number of microdomain type as we can have 
  //             microdomain between BK(Ca) and CaN/P
  //             microdomain between SK(Ca) and CaLv1.2
  //Suppose a ComputeBranch has 'x' compartments and 'y' microdomain per cpt
  //CHOICE 1:
  //  so: y-element volume_microdomain (i.e. all domains of same type have the same volumes along 1 ComputeBranch)
  //      y-element v_efflux (i.e. all domains of same type have the same efflux-rate)
  //      (x*y)-element Ca_microdomain;
  //      (x*y)-element channelCaCurrents_microdomain;
  dyn_var_t [] Ca_microdomain; //[uM] - concentration of calcium in the domain - assume instantaneous
  dyn_var_t [] Ca_microdomain_cur; //[uM] - concentration of calcium in the domain - assume instantaneous
  dyn_var_t [] volume_microdomain; //[um^3] - volume of the microdomain
  dyn_var_t [] v_efflux;  //[1/ms] - transfer rate from microdomain to cytosolic bath
  //string[] microdomainAssociatedWithChannelCaCurrents;
  //      y-element microdomainNames array
  string [] microdomainNames;
  dyn_var_t [] RHS_microdomain ; // [um/ms] - to support the solver
  //dyn_var_t [] currentDensityToConc_microdomain;

  //CHOICE 2:
  //      y-element Ca_microdomain (i.e. all domains of same type have the same efflux-rate)
  //      y-element(row) * x-element(col) channelCaCurrents_microdomain
  //  CalciumMicrodomain [] Ca_microdomain; //[uM] - concentration of calcium in the domain
  //  ChannelCaCurrents [][] channelCaCurrents_microdomain;  // [pA/um^2]
  ////      y-element microdomainNames array
  //  string [] microdomainNames;

#endif
  //}}}

  // currents
  //CONVENTION: the currents flowing toward the cytosol get negative value
  // yet it contribute positive to the increase of [Ca2+](cyto)
  // so dCa/dt = - Icurrent * A/(zCa*F*Vcyto)
  //     A = surface area Cyto = surface area SL
  // so dCa/dt = - Icurrent * A/(zCa*F*Vcyto)
  //     A = surface area ER
  // In the case of Ca2+ channels (L,N,PQ,R,T), 
  //      if channel current is negative (which means Ca2+ influx), 
  //            so ICa(channel) is the same as chanel current (i.e. negative)
  // In the case of NCX, 
  //      if INCX is negative (which means Ca2+ extrude), 
  //            so ICa(NCX) must be positive
  ChannelCaCurrents [] channelCaCurrents;  // [pA/um^2]
#ifdef MICRODOMAIN_CALCIUM
  ChannelCaCurrents [] channelCaCurrents_microdomain;  // [pA/um^2]
#endif
  //CONVENTION:  the fluxs flowing toward the cytosol get positive
  // and it contributes positive to the increase of [Ca2+](cyto)
  ChannelCaFluxes [] channelCaFluxes; // [uM/msec]
#ifdef MICRODOMAIN_CALCIUM
  ChannelCaFluxes [] channelCaFluxes_microdomain;  // [pA/um^2]
#endif
  //CONVENTION: the currents flowing toward the cytosol get negative
  // yet it contribute positive to the increase of [Ca2+](cyto)
  ReceptorCaCurrent [] receptorCaCurrents; // [pA/um^2]
  //CONVENTION: the currents flowing toward the cytosol get positive
  // 1. current from spine-(cyto) to shaft-(cyto) and vice versa
  // 2. user-defined stimulus current
  InjectedCaCurrent [] injectedCaCurrents; // [pA]

#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_CACYTO
  TargetAttachCaConcentration [] targetAttachCaConcentration;  // [uM]
#endif
  /*}}}*/

   // design : anything currently not part of the spatial 
   //          is put here
  Shared {
    /*{{{*/
    dyn_var_t* deltaT; // time-step [ms]
    dyn_var_t DCa; // diffusion constant [um^2/ms]
    //{{{ used only for fast-buffering assumption 
    dyn_var_t DCaeff; //effective diffusion constant of Ca [um^2/ms]
    dyn_var_t beta;   // Wagner and Keizer buffering constant
    dyn_var_t bmt; // value derived from beta  [1/ms]
    dyn_var_t x_bmt; // value derived [1/ms] - no buffer
    //}}}
    dyn_var_t CaBaseline; // [uM]

#ifdef  USE_CALCIUM_INDICATOR
    dyn_var_t FluoT; // total concentration [uM]
    dyn_var_t kon_Fluo; // 1/msec * uM
    dyn_var_t koff_Fluo;  // 1/msec
#endif
    InitPhase deriveParameters;  
    /*}}}*/
  }

	//{{{output data
#ifdef MICRODOMAIN_CALCIUM
  CaMicrodomainConcentrationArrayProducer.CaConcentrations << &Ca_microdomain;
  CaMicrodomainNameArrayProducer.microdomainNames << &microdomainNames;
#endif
  CaConcentrationArrayProducer.CaConcentrations << &Ca_new;
  SolutionArrayProducer.solutionArray << &Ca_new;
  DimensionArrayProducer.dimensionArray << &dimensions;
  BranchDataProducer.branchData << branchData;
  ForwardSolutionArrayProducer.AiiArray << &Aii;
  ForwardSolutionArrayProducer.AipArray << &Aip;
  ForwardSolutionArrayProducer.RHSArray << &RHS;
	//}}}

    /*{{{ Phases methods*/
  InitPhase initializeCompartmentData;
#ifdef MICRODOMAIN_CALCIUM
//TUAN MICRODOMAIN
//TODO: how to define v_efflux  and volume
// for each microdomain
#endif

#if MAX_COMPUTE_ORDER>0
  RuntimePhase forwardSolve1, backwardSolve1; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve1_corrector, backwardSolve1_corrector; 
#endif
#endif

#if MAX_COMPUTE_ORDER>1
  RuntimePhase forwardSolve2, backwardSolve2; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve2_corrector, backwardSolve2_corrector; 
#endif
#endif

#if MAX_COMPUTE_ORDER>2
  RuntimePhase forwardSolve3, backwardSolve3; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve3_corrector, backwardSolve3_corrector; 
#endif
#endif

#if MAX_COMPUTE_ORDER>3
  RuntimePhase forwardSolve4, backwardSolve4; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve4_corrector, backwardSolve4_corrector; 
#endif
#endif

#if MAX_COMPUTE_ORDER>4
  RuntimePhase forwardSolve5, backwardSolve5; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve5_corrector, backwardSolve5_corrector; 
#endif
#endif

#if MAX_COMPUTE_ORDER>5
  RuntimePhase forwardSolve6, backwardSolve6; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve6_corrector, backwardSolve6_corrector; 
#endif
#endif

#if MAX_COMPUTE_ORDER>6
  RuntimePhase forwardSolve7, backwardSolve7; 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  RuntimePhase forwardSolve7_corrector, backwardSolve7_corrector; 
#endif
#endif

#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_PREDICTOR_CORRECTOR
  //RuntimePhase forwardSolve0, backwardSolve0; 
  RuntimePhase forwardSolve0_corrector, backwardSolve0_corrector; 
#endif
  RuntimePhase solve, finish;
    /*}}}*/

  InAttrPSet {	
    string identifier;
    TissueSite site;
    int idx;
    float branchProp;
#ifdef MICRODOMAIN_CALCIUM
    string domainName; //empty means current going straight to well-mixed cytosol
#endif
  }

  // d^2 Ca/dx^2 = dCa/dt + ICaleak + ICainject + (ICasyn+ICaion)
  // injectedCurrent  = (to a compartment) only if 2 scenarios
  //               1. it forms an bi-directional
  //                      connection (e.g. electrical-synapse or spine-neck)
  //               2. a stimulus current is injected
  UserFunction setReceptorCaCurrent, setInjectedCaCurrent, setProximalJunction;
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_CACYTO
  UserFunction  setTargetAttachCaConcentration;
#endif

  //{{{Connection setup 
  Connection Pre Constant (PSet.identifier=="dimension") Expects DimensionProducer {
    DimensionProducer.dimension >> dimensions;
   }

#ifdef MICRODOMAIN_CALCIUM
  UserFunction createMicroDomainData;
#endif
  Connection Pre Constant (PSet.identifier=="branchData") Expects BranchDataProducer {
    BranchDataProducer.branchData >> branchData;
#ifdef MICRODOMAIN_CALCIUM
    createMicroDomainData();
#endif
   }

#ifdef MICRODOMAIN_CALCIUM
//  UserFunction createMicroDomainData; -- not a selected approach (use via branchData connection)
//  Connection Pre Node (PSet.identifier=="makeDomain") Expects CaCurrentArrayProducer {
//    //CaCurrentArrayProducer.currents >> channelCaCurrents.currents;
//    createMicroDomainData();
//  }
  UserFunction setupCurrent2Microdomain;
  Connection Pre Node (PSet.identifier=="channels[Calcium(domain)]") Expects 
    CaCurrentArrayProducer 
  {
    CaCurrentArrayProducer.currents >> channelCaCurrents_microdomain.currents;
//TUAN: put to the microdomain Ca2+ data
    setupCurrent2Microdomain();
  }
#endif
  //Trans-plasma-membrane Ca2+ channel produce current
  Connection Pre Node (PSet.identifier=="channels[Calcium]") Expects CaCurrentArrayProducer {
    CaCurrentArrayProducer.currents >> channelCaCurrents.currents;
   }

  //TUAN; TODO how to project RYR, IP3R calcium from CalciumER
/*
OPTIION 1: use as ionic current (pA/um^2)
  Connection Pre Node (PSet.identifier=="channels[Calcium]") Expects CaERCurrentArrayProducer {
    CaERCurrentArrayProducer.currents >> channelER_CaCurrents.currents;
    CaERCurrentArrayProducer.areas >> channelER_CaCurrents.areas;
   }
and we treat them differently in CaConcentration when mapping from currents to 
[Ca2+](cyto)
as they have different surface area

OPTION 3:
   Use as injectedCurrent (pA)
*/

// OPTION 2: channel produce flux JCa (uM/msec) instead of current ICa (pA/um^2)
  //Trans-ER-membrane Ca2+ channel produce flux 
  Connection Pre Node (PSet.identifier=="channels[Calcium]") Expects CaFluxArrayProducer {
    CaFluxArrayProducer.fluxes >> channelCaFluxes.fluxes;
   }

#ifdef MICRODOMAIN_CALCIUM
  UserFunction setupFlux2Microdomain;
  Connection Pre Node (PSet.identifier=="channels[Calcium(domain)]") Expects CaFluxArrayProducer {
    CaFluxArrayProducer.fluxes >> channelCaFluxes_microdomain.fluxes;
//TUAN: put to the microdomain Ca2+ data
    setupFlux2Microdomain();
   }
#endif

  //Connection Pre Node (PSet.identifier=="electricalSynapse[Calcium]") Expects CaCurrentProducer {
  //  CaCurrentProducer.current >> injectedCaCurrents.current;
  //  setInjectedCaCurrent();
  // }

#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_CACYTO
  Connection Pre Node (PSet.identifier=="spineAttachment[Calcium]") Expects 
             ReversalCaProducer, InverseTimeCaProducer{
    ReversalCaProducer.Ca >> targetAttachCaConcentration.Ca ;
    InverseTimeCaProducer.inverseTime >> targetAttachCaConcentration.inverseTime;
    setTargetAttachCaConcentration();
   }
#else
  Connection Pre Node (PSet.identifier=="spineAttachment[Calcium]") Expects CaCurrentProducer {
    CaCurrentProducer.current >> injectedCaCurrents.current;
    setInjectedCaCurrent();
   }
#endif

  Connection Pre Node (PSet.identifier=="chemicalSynapse[Calcium]") Expects CaCurrentProducer {
    // for receptors like NMDAR
    CaCurrentProducer.current >> receptorCaCurrents.current;
    setReceptorCaCurrent();
   }

  PredicateFunction checkSite;
  Connection Pre Variable (PSet.identifier=="stimulation" && checkSite()) Expects CaCurrentProducer {
    CaCurrentProducer.current >> injectedCaCurrents.current;
    setInjectedCaCurrent();
   }

  Connection Pre Node (PSet.identifier=="proximalJunctionPoint") Expects CaConcentrationProducer, DimensionProducer {
    CaConcentrationProducer.Ca >> proximalCaConcentration;
    DimensionProducer.dimension >> proximalDimension;
    setProximalJunction();
  }

  Connection Pre Node (PSet.identifier=="backwardSolvePoint") Expects SolutionProducer, DimensionProducer {
    SolutionProducer.solution >> proximalCaConcentration;
    DimensionProducer.dimension >> proximalDimension;
  }

  Connection Pre Node (PSet.identifier=="distalJunctionPoint") Expects CaConcentrationProducer, DimensionProducer {
    CaConcentrationProducer.Ca >> distalInputs;
    DimensionProducer.dimension >> distalDimensions;
  }

  Connection Pre Node (PSet.identifier=="forwardSolvePoint") Expects ForwardSolutionProducer, DimensionProducer {
    ForwardSolutionProducer.Aii >> distalAiis;
    ForwardSolutionProducer.Aip >> distalAips;
    ForwardSolutionProducer.RHS >> distalInputs;
    DimensionProducer.dimension >> distalDimensions;
  }

  PredicateFunction confirmUniqueDeltaT;
  Connection Pre Constant (PSet.identifier=="dt" && confirmUniqueDeltaT()) Expects TimeStepProducer {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
  //}}}
/*}}}*/
}

// represent an end-point (i.e. last compartment in the series of compartments along a branch)
// thus dont hold real data, just a reference to that last segment
Node CaConcentrationEndPoint Implements CaConcentrationProducer, DimensionProducer
{
// For each regular compute-branch (i.e. not a junction), represented by CaConcentration 
// we need 2 associated EndPoints instances, one references to 'distalEnd' and the other to 'proximalEnd'
/*{{{*/
	// single value
  dyn_var_t* CaConcentration; // reference to the Ca(cyto) of the compartment at either 'distalEnd' or 'proximalEnd' end-point compartment
  DimensionStruct* dimension; //reference to the struct representing the compartment

  Shared {
    // so the two instances share the Branchs data
		// an array but indeed is a scalar
    dyn_var_t []* CaConcentrationConnect;
    DimensionStruct* []* dimensionsConnect;
  }
    //output
  CaConcentrationProducer.Ca << CaConcentration;
  DimensionProducer.dimension << dimension;

  InAttrPSet {//attribute of the incoming MDL component, e.g. node
    string identifier;
  }

  UserFunction setPointers;// which is called to create the proper memory reference for 'Ca(cyto)' of the end-point component which
            // can be 'distalEnd' or 'proximalEnd' depending upon the incoming nodes InAttrPsets identifiers value

  // Connection setup (i.e. input)
  Connection Pre Node () Expects CaConcentrationArrayProducer, DimensionArrayProducer {
    CaConcentrationArrayProducer.CaConcentrations >> Shared.CaConcentrationConnect;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    setPointers();
  }
	// as end-point, so we use 'produce' prefix for kernels
  InitPhase produceInitialState(dimension);
  RuntimePhase produceSolvedCaConcentration(CaConcentration);
  RuntimePhase produceFinishedCaConcentration(CaConcentration);
/*}}}*/
}

// It represents one (exlicit) junction branch (which comprise half regular compartments)
Node CaConcentrationJunction Implements DimensionArrayProducer, BranchDataProducer,
     CaConcentrationArrayProducer 
#ifdef MICRODOMAIN_CALCIUM
     , CaMicrodomainConcentrationArrayProducer
     , CaMicrodomainNameArrayProducer
#endif
{
/*{{{single-compartment CB*/ 
	//DATA
  //{{{
  BranchDataStruct* branchData; // the proximal-side regular-branchs data
  DimensionStruct* [] dimensions;
    //{{{data members: internal, but for solver
  dyn_var_t* [] CaConcentrationInputs;
  DimensionStruct* [] dimensionInputs;
  BranchDataStruct* [] branchDataInputs;  // 
    //}}}
    //{{{data members: internal
  dyn_var_t volume;
  dyn_var_t [] fAxial; //axial-flux
  dyn_var_t Ca_cur;
  dyn_var_t [] Ca_new;
  dyn_var_t currentDensityToConc;
#ifdef  USE_CALCIUM_INDICATOR
  dyn_var_t Fluo;  //[uM]
  dyn_var_t FluoCa;// Ca2+-bound [uM]
#endif
  //dyn_var_t  CaClearance; // [1/ms]
  //{{{microdomain
#ifdef MICRODOMAIN_CALCIUM
//NOTE: first [] = number of compartments per compute-branch
//     second [] = number of microdomain type as we can have 
//             microdomain between BK(Ca) and CaN/P
//             microdomain between SK(Ca) and CaLv1.2
//Suppose a ComputeBranch has 'x' compartments and 'y' microdomain per cpt
//CHOICE 1:
//  so: y-element volume_microdomain (i.e. all domains of same type have the same volumes along 1 ComputeBranch)
//      y-element v_efflux (i.e. all domains of same type have the same efflux-rate)
//      (x*y)-element Ca_microdomain;
//      (x*y)-element channelCaCurrents_microdomain;
  dyn_var_t [] Ca_microdomain; //[uM] - concentration of calcium in the domain - assume instantaneous
  dyn_var_t [] Ca_microdomain_cur; //[uM] - concentration of calcium in the domain - assume instantaneous
  dyn_var_t [] Jefflux_microdomain ; // [um/ms] - to support the solver
  dyn_var_t [] volume_microdomain; //[um^3] - volume of the microdomain
  dyn_var_t []v_efflux;  //[1/ms] - transfer rate from microdomain to cytosolic bath
 // string[] microdomainAssociatedWithChannelCaCurrents;
//      y-element microdomainNames array
  string [] microdomainNames;
  dyn_var_t [] RHS_microdomain ; // [um/ms] - to support the solver
  //dyn_var_t [] currentDensityToConc_microdomain;

//CHOICE 2:
//      y-element Ca_microdomain (i.e. all domains of same type have the same efflux-rate)
//      y-element(row) * x-element(col) channelCaCurrents_microdomain
//  CalciumMicrodomain [] Ca_microdomain; //[uM] - concentration of calcium in the domain
//  ChannelCaCurrents [][] channelCaCurrents_microdomain;  // [pA/um^2]
////      y-element microdomainNames array
//  string [] microdomainNames;

#endif
  //}}}

  //{{{ ionic currents
  //CONVENTION: the currents flowing toward the cytosol get negative value
  // yet it contribute positive to the increase of [Ca2+](cyto)
  ChannelCaCurrents [] channelCaCurrents;
#ifdef MICRODOMAIN_CALCIUM
  ChannelCaCurrents [] channelCaCurrents_microdomain;  // [pA/um^2]
#endif
  //CONVENTION:  the fluxs flowing toward the cytosol get positive
  // and it contributes positive to the increase of [Ca2+](cyto)
  ChannelCaFluxes [] channelCaFluxes; // [uM/msec]
#ifdef MICRODOMAIN_CALCIUM
  ChannelCaFluxes [] channelCaFluxes_microdomain;  // [pA/um^2]
#endif
  //CONVENTION: the currents flowing toward the cytosol get negative
  // yet it contribute positive to the increase of [Ca2+](cyto)
  dyn_var_t* [] receptorCaCurrents;
#ifdef MICRODOMAIN_CALCIUM
  dyn_var_t* [] receptorCaCurrents_microdomain;
#endif
  //CONVENTION: the currents flowing toward the cytosol get positive
  // 1. current from spine-(cyto) to shaft-(cyto) and vice versa
  // 2. user-defined stimulus current
  dyn_var_t* [] injectedCaCurrents;
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_CACYTO
  dyn_var_t* [] targetReversalCaConcentration;
  dyn_var_t* [] targetInverseTimeCaConcentration;
#endif
  //}}}
  //}}}


  Shared {
	  //{{{
    dyn_var_t* deltaT;
    dyn_var_t DCa; // diffusion constant [um^2/ms]
    //{{{ used only for fast-buffering assumption 
    dyn_var_t DCaeff; //effective diffusion constant of Ca [um^2/ms]
    dyn_var_t beta;   // Wagner and Keizer buffering constant
    dyn_var_t bmt; // value derived from beta 
    dyn_var_t x_bmt; // value derived [1/ms] - no buffer
    //}}}
    dyn_var_t CaBaseline; // [uM]

#ifdef  USE_CALCIUM_INDICATOR
    dyn_var_t FluoT; // total concentration [uM]
    dyn_var_t kon_Fluo; // 1/msec * uM
    dyn_var_t koff_Fluo;  // 1/msec
#endif
    InitPhase deriveParameters;  
    //}}}
  }
  //}}}

  //{{{output data
#ifdef MICRODOMAIN_CALCIUM
  CaMicrodomainConcentrationArrayProducer.CaConcentrations << &Ca_microdomain;
  CaMicrodomainNameArrayProducer.microdomainNames << &microdomainNames;
#endif
  CaConcentrationArrayProducer.CaConcentrations << &Ca_new;
  DimensionArrayProducer.dimensionArray << &dimensions;
  BranchDataProducer.branchData << branchData;
  //}}}

  //{{{Phases methods
  InitPhase initializeJunction;
  RuntimePhase predictJunction, correctJunction;
  //}}}

  InAttrPSet {
    string identifier;
    TissueSite site;
    int idx;
#ifdef MICRODOMAIN_CALCIUM
    string domainName; //empty means current going straight to well-mixed cytosol
#endif
  }	

  //{{{Connection setup 
  // junction-branch connects to regular-branch through the regular-branchs endpoints
  Connection Pre Node (PSet.identifier=="endpoint") Expects CaConcentrationProducer, 
    DimensionProducer, BranchDataProducer  {
    CaConcentrationProducer.Ca >> CaConcentrationInputs;
    DimensionProducer.dimension >> dimensionInputs;
    BranchDataProducer.branchData >> branchDataInputs;
  }

  Connection Pre Constant (PSet.identifier=="dimension") Expects DimensionProducer {
    DimensionProducer.dimension >> dimensions;
  }

#ifdef MICRODOMAIN_CALCIUM
  UserFunction createMicroDomainData;
#endif
  Connection Pre Constant (PSet.identifier=="branchData") Expects BranchDataProducer {
    BranchDataProducer.branchData >> branchData;
#ifdef MICRODOMAIN_CALCIUM
    createMicroDomainData();
#endif
   }

#ifdef MICRODOMAIN_CALCIUM
//  UserFunction createMicroDomainData; -- not a selected approach (use via branchData connection)
//  Connection Pre Node (PSet.identifier=="makeDomain") Expects CaCurrentArrayProducer {
//    //CaCurrentArrayProducer.currents >> channelCaCurrents.currents;
//    createMicroDomainData();
//  }
  UserFunction setupCurrent2Microdomain;
  Connection Pre Node (PSet.identifier=="channels[Calcium(domain)]") Expects 
    CaCurrentArrayProducer 
  {
    CaCurrentArrayProducer.currents >> channelCaCurrents_microdomain.currents;
//TUAN: put to the microdomain Ca2+ data
    setupCurrent2Microdomain();
  }
#endif
  Connection Pre Node (PSet.identifier=="channels[Calcium]") Expects CaCurrentArrayProducer {
    CaCurrentArrayProducer.currents >> channelCaCurrents.currents;
  }

#ifdef MICRODOMAIN_CALCIUM
  UserFunction setupFlux2Microdomain;
  Connection Pre Node (PSet.identifier=="channels[Calcium(domain)]") Expects CaFluxArrayProducer {
    CaFluxArrayProducer.fluxes >> channelCaFluxes_microdomain.fluxes;
//TUAN: put to the microdomain Ca2+ data
    setupFlux2Microdomain();
   }
#endif
  Connection Pre Node (PSet.identifier=="channels[Calcium]") Expects CaFluxArrayProducer {
    CaFluxArrayProducer.fluxes >> channelCaFluxes.fluxes;
   }

  //Connection Pre Node (PSet.identifier=="electricalSynapse[Calcium]") Expects CaCurrentProducer {
  //  CaCurrentProducer.current >> injectedCaCurrents;
  //}

#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2_CACYTO
  Connection Pre Node (PSet.identifier=="spineAttachment[Calcium]") Expects 
    ReversalCaProducer, InverseTimeCaProducer{
    ReversalCaProducer.Ca >> targetReversalCaConcentration ;
    InverseTimeCaProducer.inverseTime >> targetInverseTimeCaConcentration;
  }
#else
  Connection Pre Node (PSet.identifier=="spineAttachment[Calcium]") Expects CaCurrentProducer {
    CaCurrentProducer.current >> injectedCaCurrents;
  }
#endif

  Connection Pre Node (PSet.identifier=="chemicalSynapse[Calcium]") Expects CaCurrentProducer {
    CaCurrentProducer.current >> receptorCaCurrents;
  }
#ifdef MICRODOMAIN_CALCIUM
//  UserFunction createMicroDomainData; -- not a selected approach (use via branchData connection)
//  Connection Pre Node (PSet.identifier=="makeDomain") Expects CaCurrentArrayProducer {
//    //CaCurrentArrayProducer.currents >> channelCaCurrents.currents;
//    createMicroDomainData();
//  }
  UserFunction setupReceptorCurrent2Microdomain;
  Connection Pre Node (PSet.identifier=="chemicalSynapse[Calcium(domain)]") Expects 
    CaCurrentProducer 
  {
    CaCurrentProducer.current >> receptorCaCurrents_microdomain;
//TUAN: put to the microdomain Ca2+ data
    setupReceptorCurrent2Microdomain();
  }
#endif

  PredicateFunction checkSite;
  Connection Pre Variable (PSet.identifier=="stimulation" && checkSite()) Expects 
    CaCurrentProducer 
  {
    CaCurrentProducer.current >> injectedCaCurrents;
  }

  PredicateFunction confirmUniqueDeltaT;
  Connection Pre Constant (PSet.identifier=="dt" && confirmUniqueDeltaT()) Expects 
    TimeStepProducer 
  {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
  //}}}
/*}}}*/
}

Node CaConcentrationJunctionPoint Implements CaConcentrationProducer, DimensionProducer
{
// For each junction-branch, represented by HodgkinHuxleyVoltageJunction
// we need 1 associated JunctionPoints that reference to the end...
/*{{{*/
  dyn_var_t* CaConcentration;
  DimensionStruct* dimension;

  Shared {
    dyn_var_t []* CaConcentrationConnect;
    DimensionStruct* []* dimensionsConnect;
  }
  CaConcentrationProducer.Ca << CaConcentration;
  DimensionProducer.dimension << dimension;

  InAttrPSet {
    string identifier;
  }

  UserFunction setPointers;

  Connection Pre Node () Expects CaConcentrationArrayProducer, DimensionArrayProducer {
    CaConcentrationArrayProducer.CaConcentrations >> Shared.CaConcentrationConnect;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    setPointers();
  }
  InitPhase produceInitialState(dimension);
  RuntimePhase produceCaConcentration(CaConcentration);
/*}}}*/
}

#endif
