// =============================================================================
// (C) Copyright IBM Corp. 2005-2025. All rights reserved.
//
// Distributed under the terms of the Apache License
// Version 2.0, January 2004.
// (See accompanying file LICENSE or copy at http://www.apache.org/licenses/.)
//
// =============================================================================

#ifndef Connexon_MDL
#define Connexon_MDL

#include "../../nti/include/MaxComputeOrder.h"

#include "../std/std.mdl"
#include "../BranchSolver/BranchSolver.mdl"
#include "../HodgkinHuxley/HodgkinHuxley.mdl"

//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
Interface CountProducer {
   int * countGapJunction;
}
#endif

// A Connexon is a gap junctionn
//      bidirectional connection between
//      2 compartmental branches
Node Connexon Implements 
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2
     ConductanceProducer,ReversalPotentialProducer,
#else
     CurrentProducer, 
#endif
     BranchDataProducer, IndexProducer, 
//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
     CountProducer,
#endif
     VoltageProducer
{ // for historical purpose (we still keep it here; use Connexon_Vm instead)
/*{{{*/
  dyn_var_t* Vi; //reference to the compartment representing the spine neck 
  dyn_var_t* Vj; //reference to the compartment representing the spine 'head'
  dyn_var_t I;   //the current [pA]
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2
  dyn_var_t g;   //the conductance [nS/um^2] that current from neck to shaft sense 
#else
  dyn_var_t g;   //the conductance [nS] between the gap junction formed by 2 compartments
                 // .. from 2 different branches
#endif
//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  int *countGapJunctionConnectedToCompartment_i; //keep track how many spines attached to a compartment 
  int *countGapJunctionConnectedToCompartment_j; //keep track how many spines attached to a compartment 
#endif

  BranchDataStruct* branchData; // reference to the branch having the compartment of Vi
  int index;
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2
  DimensionStruct  dimension; // of the compartment (can be neck or shaft) that this SpineAttachment object connect to
#endif

  Shared {
    //{{{
    dyn_var_t []* voltageConnect;
    DimensionStruct* []* dimensionsConnect;
//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    int []* countGapJunctionConnect;
#endif
    //}}}
  }

  InitPhase produceInitialVoltage(Vi
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
      , countGapJunctionConnectedToCompartment_i
#endif
             );
  RuntimePhase produceVoltage(Vi), computeState;

  VoltageProducer.voltage << Vi;
#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION2
  ConductanceProducer.conductance << &g;
  ReversalPotentialProducer.reversalPotential << Vj;
#else
  CurrentProducer.current << &I;
#endif
  BranchDataProducer.branchData << branchData;
  IndexProducer.index << &index;
//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
  CountProducer.countGapJunction << countGapJunctionConnectedToCompartment_i;
#endif

  InAttrPSet {
    string identifier;
    int idx;
    float branchProp;
  }

  UserFunction setPointers;
  
  Connection Pre Node (PSet.identifier=="compartment[Voltage]") Expects 
//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
      CountInformationArrayProducer, 
#endif
    VoltageArrayProducer, BranchDataProducer, DimensionArrayProducer 
  {
    VoltageArrayProducer.voltageArray >> Shared.voltageConnect;
    BranchDataProducer.branchData >> branchData;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    CountInformationArrayProducer.countGapJunctionConnected >> Shared.countGapJunctionConnect;
#endif
    setPointers();
  }
  Connection Pre Node (PSet.identifier=="connexon[Voltage]") Expects 
//#ifdef CONSIDER_MANYSPINE_EFFECT_OPTION1
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    CountProducer,
#endif
    VoltageProducer 
  {
    VoltageProducer.voltage >> Vj;
#if defined(CONSIDER_MANYSPINE_EFFECT_OPTION1) || defined(CONSIDER_MANYSPINE_EFFECT_OPTION2_revised)
    CountProducer.countGapJunction >> countGapJunctionConnectedToCompartment_j;
#endif
  }
/*}}}*/
}

Node VoltageAdapter Implements 
     BranchDataProducer, IndexProducer, 
     DimensionProducer,
     VoltageProducer
{ // for historical purpose (we still keep it here; use Connexon_Vm instead)
/*{{{*/

  dyn_var_t* Vi; 
  BranchDataStruct* branchData; // reference to the branch having the compartment of Vi
  int index;
  DimensionStruct*  dimension; // of the compartment (can be neck or shaft) that this SpineAttachment object connect to

  Shared {
    //{{{
    dyn_var_t []* voltageConnect;
    DimensionStruct* []* dimensionsConnect;
    //}}}
  }

  InitPhase produceInitialVoltage(Vi, dimension);
  RuntimePhase produceVoltage(Vi);

  DimensionProducer.dimension << dimension;
  VoltageProducer.voltage << Vi;
  BranchDataProducer.branchData << branchData;
  IndexProducer.index << &index;

  InAttrPSet {
    string identifier;
    int idx;
    float branchProp;
  }

  UserFunction setPointers;
  
  Connection Pre Node (PSet.identifier=="compartment[Voltage]") Expects 
    VoltageArrayProducer, BranchDataProducer, DimensionArrayProducer 
  {
    VoltageArrayProducer.voltageArray >> Shared.voltageConnect;
    BranchDataProducer.branchData >> branchData;
    DimensionArrayProducer.dimensionArray >> Shared.dimensionsConnect;   
    setPointers();
  }
/*}}}*/
}
#endif
