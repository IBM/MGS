#!/bin/bash
#// =================================================================
#// Licensed Materials - Property of IBM
#//
#// "Restricted Materials of IBM"
#//
#// BCM-YKT-07-18-2017
#//
#// (C) Copyright IBM Corp. 2005-2017  All rights reserved
#//
#// US Government Users Restricted Rights -
#// Use, duplication or disclosure restricted by
#// GSA ADP Schedule Contract with IBM Corp.
#//
#// =================================================================
### UPDATE:
# (Aug-08-2017)
#  comment starting with // is allowed in *.mdf file
#  MDL file in sub-folder is allowed now
#  automatically detect change in MDL file
#  all.mdf is the one used by the build-script in that user can add
#       - mdl files
#       - mdf files
#   (NOTE: only all.mdf can contain MDF files)
#  tolerate to non-existence MDF file
### KNOWN LIMITATION:
# 1. once a component in the MDL file is added/changed --> the whole MDL file is recompiled
#       (so try not to put so many components in one MDL file)
# 2. it doesn't automatically compile for #include MDL file (as the generated file is expected to be in a different location)
# HOW TO USE
# ./define <file.mdf> [-rebuild]

#{{{
function run_mdlparser() {
  #{{{
  # NOTE: $MGSROOT/extensions/functor need to be added explicitly to configure.py
  #temp_mdf_only=$(mktemp)
  #temp_mdl_only=$(mktemp)
  #grep  '^[^//]' $1 | gawk '/mdf"/ {print $2}' > ${temp_mdf_only}
  #grep  '^[^//]' $1 | gawk '/mdl"/ {print}' > ${temp_mdl_only}
  $MDLROOT/bin/mdlparser $1 -i $MGSROOT/extensions/variable:$MGSROOT/extensions/struct -n;
  #$MDLROOT/bin/mdlparser `cat ${temp_mdf_only} | tr '\n' ' ' ` ${temp_mdfl_only} -i $MGSROOT/extensions/variable:$MGSROOT/extensions/struct;
  #}}}
}
#}}}

temp_mdf_only=$(mktemp)
temp_mdl_only=$(mktemp)
grep  '^[^//]' $1 | gawk '/mdf"/ {print}' > ${temp_mdf_only}
grep  '^[^//]' $1 | gawk '/mdl"/ {print}' > ${temp_mdl_only}

MDLFILES=()
sed '/\\/p' ${temp_mdl_only}| sed 's/#include "/cd /g' | sed 's/\(.*\)\//\1 ; $MDLROOT\/bin\/mdlparser /g' | sed 's/"/ -n ; sh copyModules ; cd - ;/g' > defineModels1.sh;
while read mdl_in; do
  mdl_file_name=`echo $mdl_in | gawk  '{print \$2}' | sed -e "s/^\"//" -e "s/\"$//"  `
  MDLFILES+=($mdl_file_name)
done < $temp_mdl_only
while read in; do
  file_name=`echo $in | gawk  '{print \$2}' | sed -e "s/^\"//" -e "s/\"$//"  `
  if [ -f $file_name ]; then
    cat ${file_name} | grep  '^[^//]'  | sed '/\\/p' | sed 's/#include "/cd /g' | sed 's/\(.*\)\//\1 ; $MDLROOT\/bin\/mdlparser /g' | sed 's/"/ -n ; sh copyModules ; cd - ;/g' >> defineModels1.sh;
    temp_file_name=$(mktemp)
    grep  '^[^//]' $1 | gawk '/mdl"/ {print}' > ${temp_file_name}
    while read mdl_in; do
      mdl_file_name=`echo $mdl_in | gawk  '{print \$2}' | sed -e "s/^\"//" -e "s/\"$//"  `
      MDLFILES+=($mdl_file_name)
    done < $temp_file_name
  fi
done < ${temp_mdf_only}

RERUN=0
if [ $# -gt 1 ] && [ $2 == "-rebuild" ]; then
  gawk '{ print  $0 }' defineModels1.sh > defineModels2.sh;
  RERUN=1
else
  gawk 'NF { print "if [ ! -f " $2 "/" $5" ]; then echo \" not found: " $2 "/" $5 "\"; exit 1; fi; if [ '$1' -ot " $2 "/" $5 " ] || { [ define -ot '$1' ] && [ define -ot " $2 "/" $5 " ];}; then " $0 " fi; for i in \$(gawk -F\" |{\"  '"'"'{for(i=1;i<=NF;i++) if (\$i==\"Node\" && \$(i+2)==\"Implements\") {print \$(i+1);}}'"'"' " $2 "/" $5 "); do if [ ! -d " $2 "/$i ]; then " $0 " fi; done; for i in \$(gawk -F\" |{\" '"'"'{for(i=1;i<=NF;i++) if (\$i==\"Constant\" && \$(i+2)==\"Implements\") {print \$(i+1);}}'"'"' " $2 "/" $5 "); do if [ ! -d " $2 "/$i ]; then " $0 " fi; done; for i in \$(gawk -F\" |{\" '"'"'{if (\$1==\"Variable\" ) {print \$(2);}}'"'"' " $2 "/" $5 "); do if [ ! -d " $2 "/$i ]; then " $0 " fi; done; for i in \$(comm -12 <(cpp " $2 "/" $5 "|gawk -F\" |{\" '"'"'{if (\$1==\"Interface\" ) {print \$(2);}}'"'"'|sort) <(gawk -F\" |{\" '"'"'{if (\$1==\"Interface\" ) {print \$(2);}}'"'"' " $2 "/" $5 "|sort)); do if [ ! -d " $2 "/$i ]; then " $0 " fi; done; if ! cmp --silent <(cpp " $2 "/" $5")   " $2 "/." $5 "; then cpp " $2 "/" $5 " >" $2 "/." $5 ";" $0 " fi" }' defineModels1.sh > defineModels2.sh;
fi

set -e
source defineModels2.sh;
rm -f defineModels1.sh;
rm -f defineModels2.sh;
##NOTE: we need this to regenerate Extension.mk file (yet it doesn't rebuild)
REGEN=0
if [ ! -f $MGSROOT/Extensions.mk ]; then
  run_mdlparser $1; REGEN=1;
fi
if [ define -ot $1 ] && [ "$RERUN" -eq 1 ]; then run_mdlparser $1;  REGEN=1; fi
if [ $REGEN -eq 0 ]; then
  if [ define -ot $1 ] && [ "$2" == "-force" ]; then run_mdlparser $1; REGEN=1; fi
fi
#$MDLROOT/bin/mdlparser $1 -i $MGSROOT/extensions/variable:$MGSROOT/extensions/struct;
for i in "${MDLFILES[@]}"
do
  if [ define -ot $i ]; then RERUN=1; cpp $i > $(dirname "${i}")"/."$(basename "${i}"); fi
  touch $i
done
if [ "$RERUN" -eq 1 ]  && [ $REGEN -eq 0 ]; then run_mdlparser $1; REGEN=1; fi
touch $1
sleep 2
touch define;
touch $MGSROOT/Extensions.mk
cp $MGSROOT/Extensions.mk{,.bak}
cp Extensions.mk $MGSROOT
rm ${temp_mdf_only}
rm ${temp_mdl_only}
