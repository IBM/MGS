#ifndef ChannelRYR_MDL
#define ChannelRYR_MDL

#include "../../nti/include/MaxComputeOrder.h"

#include "../std/std.mdl"
#include "../HodgkinHuxley/HodgkinHuxley.mdl"
#include "../BranchSolver/BranchSolver.mdl"

// NOTE: This channel get data from 2 compartment variables: CalciumER + Calcium
// Stochastic simulation 
Node SingleChannelRYR Implements BranchDataProducer,
   CaFluxArrayProducer
   //ConductanceArrayProducer, 
   //CaCurrentArrayProducer
{
  /*{{{*/
  //DATA
  //{{{ 
  // Markov-based formula
  //{{{
  //{{{
  //internal data
  // NOTE: The flux is expected to get positive value if flowing toward cytosol
  dyn_var_t [] J_Ca; // [uM/msec]
  int [] numChan; //integer = channelDensity * ERsurfaceArea
  int [] numClusterStates;
  int []  maxNumNeighbors;
  int * [] matClusterStateInfo; //for each cpt, for each line is a vector representing #channels in each cluster-state
  int * []  vClusterNumOpenChan;
  //Combined2MarkovState_t *[] matK_channelstate_fromto;
  long * [] matK_channelstate_fromto;
  ClusterStateIndex_t * [] matK_indx;
  dyn_var_t * [] matChannelTransitionRate;// numChanStates*numChanStates matrix
  ClusterStateIndex_t [] currentStateIndex;
  dyn_var_t* [] probStateTransition;
  // RyR specific
  dyn_var_t [] Ej; // unitless = average RyR connectivity
  dyn_var_t [] v_ryr; // the transfer rate [1/ms]

  //data mainly used to dynamically assign different channel density on different location
  //NOTE: In SynParams.par file
  //    Use either ChanDenbar_dists or ChanDenbar_branch
  //      and combine with ChanDenbar_values
  // NOTE: This overwrite the values passed by in Shared region
  dyn_var_t [] ChanDenbar_dists; // an array that indicate the threshold-distance (in micrometer)
  dyn_var_t [] ChanDenbar_branchorders;// an array that indicate the branch-order (zero-based integer)
  dyn_var_t [] ChanDenbar_values;// ... having the corresponding channel density [1/um^2]
  // Example:
  // CHANNEL_PARAMS 2
  // RyR 3
  // BRANCHTYPE MTYPE
  // [1/um^2]
  // 1 0 <ChanDenbar={0.02}>
  // 4 0 <ChanDenbar_dists={380.0,480.0, 590}> 
  // 4 0 <ChanDenbar_values={0.000555,0.00555,0.000555}>
  //}}}
  #ifdef MICRODOMAIN_CALCIUM
  string microdomainName; //default is empty, i.e. see cytosolic Ca2+
  #endif
  // reference data
  dyn_var_t []* Ca_IC; // intracellular Ca2+ concentration [uM]
  dyn_var_t []* Ca_ER; // ER Ca2+ concentration [uM]
  BranchDataStruct* branchData; 
  DimensionStruct* []* dimensions;
  //}}}

  //SHARED DATA
  Shared {//in xxxCompCategory.C
    //{{{
    dyn_var_t* deltaT; // [ms]
    dyn_var_t* T;     // [K]
    dyn_var_t Tadj;  // [unitless] kinetics adjustment based on recorded data 
    //   and tempt. used for the simulation 
    //dyn_var_t a; // fraction of inactivation (i.e. channel with partial inactivation properties)
    string SingleChannelModelFileName;
    dyn_var_t iryr; // single-channel current [pA]
    dyn_var_t channelDensity; // [1/um^2] - the # of RyR per 1um^2
    bool useExplicitNumberofChannels; // if true, then #channels is read-in explicitly via ChanParam file
    // if false, then #channels is calculated via channelDensity
    //{{{ to be generated
    int numChanStates; // number of Markov-based channel states
    int initialstate; // index of the starting channel-state for all channels in the cpt 
    int * vOpenStates; // vector telling which state is conducting(=1)
    dyn_var_t * matChannelRateConstant;// numChanStates*numChanStates matrix
    //}}}
    /*    
	  int [][] stateFromTo;
	  int [][] indxK;
	  int [][]_StateSpace;
	  int maxNumNeighbors;
     */
    InitPhase computeTadj; 
    InitPhase setupChannel;
  #ifdef MICRODOMAIN_CALCIUM
  string [] * tmp_microdomainNames;
  #endif
    //}}}
  }
  //}}}

  RuntimePhase update();
  InitPhase initialize;

  //ConductanceArrayProducer.conductanceArray << &g;
  //CaCurrentArrayProducer.CaCurrents << &I_Ca;
  CaFluxArrayProducer.fluxes << &J_Ca;
  BranchDataProducer.branchData << branchData;

  InAttrPSet {//information of the incoming connection
    string identifier; // name of the incoming node
    int idx;   // if identifier = name of the compartment variable 
    // then idx = index of the compartment on a branch
#ifdef MICRODOMAIN_CALCIUM
    string domainName; //default is empty, i.e. Ca2+ from cytosolic volume
#endif
  }

  //{{{Input (Connection setup)
#ifdef MICRODOMAIN_CALCIUM
  UserFunction setCalciumMicrodomain;
  Connection Pre Node (PSet.identifier=="compartment[Calcium(domain)]") Expects 
  CaMicrodomainConcentrationArrayProducer
  , CaMicrodomainNameArrayProducer
  , BranchDataProducer, DimensionArrayProducer
  {
    BranchDataProducer.branchData >> branchData;
    DimensionArrayProducer.dimensionArray >> dimensions;
    CaMicrodomainConcentrationArrayProducer.CaConcentrations >> Ca_IC;
    CaMicrodomainNameArrayProducer.microdomainNames >> Shared.tmp_microdomainNames;
    setCalciumMicrodomain();
  }
#endif
  //Connection Pre Node (PSet.identifier=="IC[Calcium]") Expects CaConcentrationArrayProducer,
  Connection Pre Node (PSet.identifier=="compartment[Calcium]") Expects CaConcentrationArrayProducer,
	     BranchDataProducer, DimensionArrayProducer 
	     {
	       CaConcentrationArrayProducer.CaConcentrations >> Ca_IC;
	       BranchDataProducer.branchData >> branchData;
	       DimensionArrayProducer.dimensionArray >> dimensions;
	     }

  Connection Pre Node (PSet.identifier=="IC[CalciumER]") Expects CaConcentrationArrayProducer {
    CaConcentrationArrayProducer.CaConcentrations >> Ca_ER;
  }

  Connection Pre Constant (PSet.identifier=="EC") 
    Expects TemperatureProducer {
      TemperatureProducer.T >> Shared.T;
    }

  Connection Pre Constant (PSet.identifier=="dt") Expects TimeStepProducer {
    TimeStepProducer.deltaT >> Shared.deltaT;
  }
  //}}}
  /*}}}*/
}


#endif
